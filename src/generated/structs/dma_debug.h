/**
 * \file
 * \brief Generated by ifgen (4.6.5).
 */

#pragma once
#ifndef RP2040_STRUCTS_DMA_DEBUG_H
#define RP2040_STRUCTS_DMA_DEBUG_H

#include "../ifgen/common.h"

namespace RP2040
{

struct dma_debug
{
    /* Constant attributes. */
    static constexpr struct_id_t id = 4;    /*!< dma_debug's identifier. */
    static constexpr std::size_t size = 64; /*!< dma_debug's size in bytes. */

    /* Fields. */
    uint32_t DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                            how many accesses the DMA expects it can perform on
                            the peripheral without overflow/underflow. Write
                            any value: clears the counter, and cause channel to
                            re-initiate DREQ handshake. */
    uint32_t DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                         value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_length = 14;
    uint32_t reserved[reserved_length];

    /* Methods. */

    /**
     * Get DBG_CTDREQ's DBG_CTDREQ field.
     */
    inline uint8_t get_DBG_CTDREQ() volatile
    {
        return DBG_CTDREQ & 0b111111u;
    }

    /**
     * Set DBG_CTDREQ's DBG_CTDREQ field.
     */
    inline void set_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = DBG_CTDREQ;

        curr &= ~(0b111111u);
        curr |= (value & 0b111111u);

        DBG_CTDREQ = curr;
    }
};

static_assert(sizeof(dma_debug) == dma_debug::size);
static_assert(ifgen_struct<dma_debug>);

static volatile dma_debug *const DMA_DEBUG_NULL =
    reinterpret_cast<dma_debug *>(0x00000000);

}; // namespace RP2040

#endif
