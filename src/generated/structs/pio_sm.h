/**
 * \file
 * \brief Generated by ifgen (4.7.1).
 */

#pragma once
#ifndef RP2040_STRUCTS_PIO_SM_H
#define RP2040_STRUCTS_PIO_SM_H

#include "../ifgen/common.h"

namespace RP2040
{

struct pio_sm
{
    /* Constant attributes. */
    static constexpr struct_id_t id = 13;   /*!< pio_sm's identifier. */
    static constexpr std::size_t size = 24; /*!< pio_sm's size in bytes. */

    /* Fields. */
    uint32_t CLKDIV; /*!< (read-write) Clock divisor register for state machine
       N Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256) */
    uint32_t EXECCTRL;  /*!< (read-write) Execution/behavioural settings for
                           state machine N */
    uint32_t SHIFTCTRL; /*!< (read-write) Control behaviour of the input/output
                           shift registers for state machine N */
    const uint32_t ADDR =
        {}; /*!< (read-only) Current instruction address of state machine N */
    uint32_t INSTR;   /*!< (read-write) Read to see the instruction currently
        addressed by state machine N's program counter   Write to execute an
        instruction immediately (including jumps) and then resume execution. */
    uint32_t PINCTRL; /*!< (read-write) State machine pin control */

    /* Methods. */

    /**
     * Get CLKDIV's FRAC field.
     *
     * Fractional part of clock divisor
     */
    inline uint8_t get_CLKDIV_FRAC()
    {
        return (CLKDIV >> 8u) & 0xffu;
    }

    /**
     * Set CLKDIV's FRAC field.
     *
     * Fractional part of clock divisor
     */
    inline void set_CLKDIV_FRAC(uint8_t value)
    {
        uint32_t curr = CLKDIV;

        curr &= ~(0xffu << 8u);
        curr |= (value & 0xffu) << 8u;

        CLKDIV = curr;
    }

    /**
     * Get CLKDIV's INT field.
     *
     * Effective frequency is sysclk/(int + frac/256).
     *                 Value of 0 is interpreted as 65536. If INT is 0, FRAC
     * must also be 0.
     */
    inline uint16_t get_CLKDIV_INT()
    {
        return (CLKDIV >> 16u) & 0xffffu;
    }

    /**
     * Set CLKDIV's INT field.
     *
     * Effective frequency is sysclk/(int + frac/256).
     *                 Value of 0 is interpreted as 65536. If INT is 0, FRAC
     * must also be 0.
     */
    inline void set_CLKDIV_INT(uint16_t value)
    {
        uint32_t curr = CLKDIV;

        curr &= ~(0xffffu << 16u);
        curr |= (value & 0xffffu) << 16u;

        CLKDIV = curr;
    }

    /**
     * Get all of CLKDIV's bit fields.
     *
     * (read-write) Clock divisor register for state machine N
     *             Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
     */
    inline void get_CLKDIV(uint8_t &FRAC, uint16_t &INT)
    {
        uint32_t curr = CLKDIV;

        FRAC = (curr >> 8u) & 0xffu;
        INT = (curr >> 16u) & 0xffffu;
    }

    /**
     * Set all of CLKDIV's bit fields.
     *
     * (read-write) Clock divisor register for state machine N
     *             Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256)
     */
    inline void set_CLKDIV(uint8_t FRAC, uint16_t INT)
    {
        uint32_t curr = CLKDIV;

        curr &= ~(0xffu << 8u);
        curr |= (FRAC & 0xffu) << 8u;
        curr &= ~(0xffffu << 16u);
        curr |= (INT & 0xffffu) << 16u;

        CLKDIV = curr;
    }

    /**
     * Get EXECCTRL's STATUS_N field.
     *
     * Comparison level for the MOV x, STATUS instruction
     */
    inline uint8_t get_EXECCTRL_STATUS_N()
    {
        return EXECCTRL & 0xfu;
    }

    /**
     * Set EXECCTRL's STATUS_N field.
     *
     * Comparison level for the MOV x, STATUS instruction
     */
    inline void set_EXECCTRL_STATUS_N(uint8_t value)
    {
        uint32_t curr = EXECCTRL;

        curr &= ~(0xfu);
        curr |= (value & 0xfu);

        EXECCTRL = curr;
    }

    /**
     * Get EXECCTRL's STATUS_SEL bit.
     *
     * Comparison used for the MOV x, STATUS instruction.
     */
    inline bool get_EXECCTRL_STATUS_SEL()
    {
        return EXECCTRL & (1u << 4u);
    }

    /**
     * Set EXECCTRL's STATUS_SEL bit.
     *
     * Comparison used for the MOV x, STATUS instruction.
     */
    inline void set_EXECCTRL_STATUS_SEL()
    {
        EXECCTRL |= 1u << 4u;
    }

    /**
     * Clear EXECCTRL's STATUS_SEL bit.
     *
     * Comparison used for the MOV x, STATUS instruction.
     */
    inline void clear_EXECCTRL_STATUS_SEL()
    {
        EXECCTRL &= ~(1u << 4u);
    }

    /**
     * Toggle EXECCTRL's STATUS_SEL bit.
     *
     * Comparison used for the MOV x, STATUS instruction.
     */
    inline void toggle_EXECCTRL_STATUS_SEL()
    {
        EXECCTRL ^= 1u << 4u;
    }

    /**
     * Get EXECCTRL's WRAP_BOTTOM field.
     *
     * After reaching wrap_top, execution is wrapped to this address.
     */
    inline uint8_t get_EXECCTRL_WRAP_BOTTOM()
    {
        return (EXECCTRL >> 7u) & 0b11111u;
    }

    /**
     * Set EXECCTRL's WRAP_BOTTOM field.
     *
     * After reaching wrap_top, execution is wrapped to this address.
     */
    inline void set_EXECCTRL_WRAP_BOTTOM(uint8_t value)
    {
        uint32_t curr = EXECCTRL;

        curr &= ~(0b11111u << 7u);
        curr |= (value & 0b11111u) << 7u;

        EXECCTRL = curr;
    }

    /**
     * Get EXECCTRL's WRAP_TOP field.
     *
     * After reaching this address, execution is wrapped to wrap_bottom.
     *                 If the instruction is a jump, and the jump condition is
     * true, the jump takes priority.
     */
    inline uint8_t get_EXECCTRL_WRAP_TOP()
    {
        return (EXECCTRL >> 12u) & 0b11111u;
    }

    /**
     * Set EXECCTRL's WRAP_TOP field.
     *
     * After reaching this address, execution is wrapped to wrap_bottom.
     *                 If the instruction is a jump, and the jump condition is
     * true, the jump takes priority.
     */
    inline void set_EXECCTRL_WRAP_TOP(uint8_t value)
    {
        uint32_t curr = EXECCTRL;

        curr &= ~(0b11111u << 12u);
        curr |= (value & 0b11111u) << 12u;

        EXECCTRL = curr;
    }

    /**
     * Get EXECCTRL's OUT_STICKY bit.
     *
     * Continuously assert the most recent OUT/SET to the pins
     */
    inline bool get_EXECCTRL_OUT_STICKY()
    {
        return EXECCTRL & (1u << 17u);
    }

    /**
     * Set EXECCTRL's OUT_STICKY bit.
     *
     * Continuously assert the most recent OUT/SET to the pins
     */
    inline void set_EXECCTRL_OUT_STICKY()
    {
        EXECCTRL |= 1u << 17u;
    }

    /**
     * Clear EXECCTRL's OUT_STICKY bit.
     *
     * Continuously assert the most recent OUT/SET to the pins
     */
    inline void clear_EXECCTRL_OUT_STICKY()
    {
        EXECCTRL &= ~(1u << 17u);
    }

    /**
     * Toggle EXECCTRL's OUT_STICKY bit.
     *
     * Continuously assert the most recent OUT/SET to the pins
     */
    inline void toggle_EXECCTRL_OUT_STICKY()
    {
        EXECCTRL ^= 1u << 17u;
    }

    /**
     * Get EXECCTRL's INLINE_OUT_EN bit.
     *
     * If 1, use a bit of OUT data as an auxiliary write enable
     *                 When used in conjunction with OUT_STICKY, writes with an
     * enable of 0 will deassert the latest pin write. This can create useful
     * masking/override behaviour due to the priority ordering of state machine
     * pin writes (SM0 < SM1 < ...)
     */
    inline bool get_EXECCTRL_INLINE_OUT_EN()
    {
        return EXECCTRL & (1u << 18u);
    }

    /**
     * Set EXECCTRL's INLINE_OUT_EN bit.
     *
     * If 1, use a bit of OUT data as an auxiliary write enable
     *                 When used in conjunction with OUT_STICKY, writes with an
     * enable of 0 will deassert the latest pin write. This can create useful
     * masking/override behaviour due to the priority ordering of state machine
     * pin writes (SM0 < SM1 < ...)
     */
    inline void set_EXECCTRL_INLINE_OUT_EN()
    {
        EXECCTRL |= 1u << 18u;
    }

    /**
     * Clear EXECCTRL's INLINE_OUT_EN bit.
     *
     * If 1, use a bit of OUT data as an auxiliary write enable
     *                 When used in conjunction with OUT_STICKY, writes with an
     * enable of 0 will deassert the latest pin write. This can create useful
     * masking/override behaviour due to the priority ordering of state machine
     * pin writes (SM0 < SM1 < ...)
     */
    inline void clear_EXECCTRL_INLINE_OUT_EN()
    {
        EXECCTRL &= ~(1u << 18u);
    }

    /**
     * Toggle EXECCTRL's INLINE_OUT_EN bit.
     *
     * If 1, use a bit of OUT data as an auxiliary write enable
     *                 When used in conjunction with OUT_STICKY, writes with an
     * enable of 0 will deassert the latest pin write. This can create useful
     * masking/override behaviour due to the priority ordering of state machine
     * pin writes (SM0 < SM1 < ...)
     */
    inline void toggle_EXECCTRL_INLINE_OUT_EN()
    {
        EXECCTRL ^= 1u << 18u;
    }

    /**
     * Get EXECCTRL's OUT_EN_SEL field.
     *
     * Which data bit to use for inline OUT enable
     */
    inline uint8_t get_EXECCTRL_OUT_EN_SEL()
    {
        return (EXECCTRL >> 19u) & 0b11111u;
    }

    /**
     * Set EXECCTRL's OUT_EN_SEL field.
     *
     * Which data bit to use for inline OUT enable
     */
    inline void set_EXECCTRL_OUT_EN_SEL(uint8_t value)
    {
        uint32_t curr = EXECCTRL;

        curr &= ~(0b11111u << 19u);
        curr |= (value & 0b11111u) << 19u;

        EXECCTRL = curr;
    }

    /**
     * Get EXECCTRL's JMP_PIN field.
     *
     * The GPIO number to use as condition for JMP PIN. Unaffected by input
     * mapping.
     */
    inline uint8_t get_EXECCTRL_JMP_PIN()
    {
        return (EXECCTRL >> 24u) & 0b11111u;
    }

    /**
     * Set EXECCTRL's JMP_PIN field.
     *
     * The GPIO number to use as condition for JMP PIN. Unaffected by input
     * mapping.
     */
    inline void set_EXECCTRL_JMP_PIN(uint8_t value)
    {
        uint32_t curr = EXECCTRL;

        curr &= ~(0b11111u << 24u);
        curr |= (value & 0b11111u) << 24u;

        EXECCTRL = curr;
    }

    /**
     * Get EXECCTRL's SIDE_PINDIR bit.
     *
     * If 1, side-set data is asserted to pin directions, instead of pin values
     */
    inline bool get_EXECCTRL_SIDE_PINDIR()
    {
        return EXECCTRL & (1u << 29u);
    }

    /**
     * Set EXECCTRL's SIDE_PINDIR bit.
     *
     * If 1, side-set data is asserted to pin directions, instead of pin values
     */
    inline void set_EXECCTRL_SIDE_PINDIR()
    {
        EXECCTRL |= 1u << 29u;
    }

    /**
     * Clear EXECCTRL's SIDE_PINDIR bit.
     *
     * If 1, side-set data is asserted to pin directions, instead of pin values
     */
    inline void clear_EXECCTRL_SIDE_PINDIR()
    {
        EXECCTRL &= ~(1u << 29u);
    }

    /**
     * Toggle EXECCTRL's SIDE_PINDIR bit.
     *
     * If 1, side-set data is asserted to pin directions, instead of pin values
     */
    inline void toggle_EXECCTRL_SIDE_PINDIR()
    {
        EXECCTRL ^= 1u << 29u;
    }

    /**
     * Get EXECCTRL's SIDE_EN bit.
     *
     * If 1, the MSB of the Delay/Side-set instruction field is used as
     * side-set enable, rather than a side-set data bit. This allows
     * instructions to perform side-set optionally, rather than on every
     * instruction, but the maximum possible side-set width is reduced from 5
     * to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this
     * enable bit.
     */
    inline bool get_EXECCTRL_SIDE_EN()
    {
        return EXECCTRL & (1u << 30u);
    }

    /**
     * Set EXECCTRL's SIDE_EN bit.
     *
     * If 1, the MSB of the Delay/Side-set instruction field is used as
     * side-set enable, rather than a side-set data bit. This allows
     * instructions to perform side-set optionally, rather than on every
     * instruction, but the maximum possible side-set width is reduced from 5
     * to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this
     * enable bit.
     */
    inline void set_EXECCTRL_SIDE_EN()
    {
        EXECCTRL |= 1u << 30u;
    }

    /**
     * Clear EXECCTRL's SIDE_EN bit.
     *
     * If 1, the MSB of the Delay/Side-set instruction field is used as
     * side-set enable, rather than a side-set data bit. This allows
     * instructions to perform side-set optionally, rather than on every
     * instruction, but the maximum possible side-set width is reduced from 5
     * to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this
     * enable bit.
     */
    inline void clear_EXECCTRL_SIDE_EN()
    {
        EXECCTRL &= ~(1u << 30u);
    }

    /**
     * Toggle EXECCTRL's SIDE_EN bit.
     *
     * If 1, the MSB of the Delay/Side-set instruction field is used as
     * side-set enable, rather than a side-set data bit. This allows
     * instructions to perform side-set optionally, rather than on every
     * instruction, but the maximum possible side-set width is reduced from 5
     * to 4. Note that the value of PINCTRL_SIDESET_COUNT is inclusive of this
     * enable bit.
     */
    inline void toggle_EXECCTRL_SIDE_EN()
    {
        EXECCTRL ^= 1u << 30u;
    }

    /**
     * Get EXECCTRL's EXEC_STALLED bit.
     *
     * If 1, an instruction written to SMx_INSTR is stalled, and latched by the
     * state machine. Will clear to 0 once this instruction completes.
     */
    inline bool get_EXECCTRL_EXEC_STALLED()
    {
        return EXECCTRL & (1u << 31u);
    }

    /**
     * Get all of EXECCTRL's bit fields.
     *
     * (read-write) Execution/behavioural settings for state machine N
     */
    inline void get_EXECCTRL(uint8_t &STATUS_N, bool &STATUS_SEL,
                             uint8_t &WRAP_BOTTOM, uint8_t &WRAP_TOP,
                             bool &OUT_STICKY, bool &INLINE_OUT_EN,
                             uint8_t &OUT_EN_SEL, uint8_t &JMP_PIN,
                             bool &SIDE_PINDIR, bool &SIDE_EN,
                             bool &EXEC_STALLED)
    {
        uint32_t curr = EXECCTRL;

        STATUS_N = curr & 0xfu;
        STATUS_SEL = curr & (1u << 4u);
        WRAP_BOTTOM = (curr >> 7u) & 0b11111u;
        WRAP_TOP = (curr >> 12u) & 0b11111u;
        OUT_STICKY = curr & (1u << 17u);
        INLINE_OUT_EN = curr & (1u << 18u);
        OUT_EN_SEL = (curr >> 19u) & 0b11111u;
        JMP_PIN = (curr >> 24u) & 0b11111u;
        SIDE_PINDIR = curr & (1u << 29u);
        SIDE_EN = curr & (1u << 30u);
        EXEC_STALLED = curr & (1u << 31u);
    }

    /**
     * Set all of EXECCTRL's bit fields.
     *
     * (read-write) Execution/behavioural settings for state machine N
     */
    inline void set_EXECCTRL(uint8_t STATUS_N, bool STATUS_SEL,
                             uint8_t WRAP_BOTTOM, uint8_t WRAP_TOP,
                             bool OUT_STICKY, bool INLINE_OUT_EN,
                             uint8_t OUT_EN_SEL, uint8_t JMP_PIN,
                             bool SIDE_PINDIR, bool SIDE_EN)
    {
        uint32_t curr = EXECCTRL;

        curr &= ~(0xfu);
        curr |= (STATUS_N & 0xfu);
        curr &= ~(0b1u << 4u);
        curr |= (STATUS_SEL & 0b1u) << 4u;
        curr &= ~(0b11111u << 7u);
        curr |= (WRAP_BOTTOM & 0b11111u) << 7u;
        curr &= ~(0b11111u << 12u);
        curr |= (WRAP_TOP & 0b11111u) << 12u;
        curr &= ~(0b1u << 17u);
        curr |= (OUT_STICKY & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (INLINE_OUT_EN & 0b1u) << 18u;
        curr &= ~(0b11111u << 19u);
        curr |= (OUT_EN_SEL & 0b11111u) << 19u;
        curr &= ~(0b11111u << 24u);
        curr |= (JMP_PIN & 0b11111u) << 24u;
        curr &= ~(0b1u << 29u);
        curr |= (SIDE_PINDIR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (SIDE_EN & 0b1u) << 30u;

        EXECCTRL = curr;
    }

    /**
     * Get SHIFTCTRL's AUTOPUSH bit.
     *
     * Push automatically when the input shift register is filled, i.e. on an
     * IN instruction which causes the input shift counter to reach or exceed
     * PUSH_THRESH.
     */
    inline bool get_SHIFTCTRL_AUTOPUSH()
    {
        return SHIFTCTRL & (1u << 16u);
    }

    /**
     * Set SHIFTCTRL's AUTOPUSH bit.
     *
     * Push automatically when the input shift register is filled, i.e. on an
     * IN instruction which causes the input shift counter to reach or exceed
     * PUSH_THRESH.
     */
    inline void set_SHIFTCTRL_AUTOPUSH()
    {
        SHIFTCTRL |= 1u << 16u;
    }

    /**
     * Clear SHIFTCTRL's AUTOPUSH bit.
     *
     * Push automatically when the input shift register is filled, i.e. on an
     * IN instruction which causes the input shift counter to reach or exceed
     * PUSH_THRESH.
     */
    inline void clear_SHIFTCTRL_AUTOPUSH()
    {
        SHIFTCTRL &= ~(1u << 16u);
    }

    /**
     * Toggle SHIFTCTRL's AUTOPUSH bit.
     *
     * Push automatically when the input shift register is filled, i.e. on an
     * IN instruction which causes the input shift counter to reach or exceed
     * PUSH_THRESH.
     */
    inline void toggle_SHIFTCTRL_AUTOPUSH()
    {
        SHIFTCTRL ^= 1u << 16u;
    }

    /**
     * Get SHIFTCTRL's AUTOPULL bit.
     *
     * Pull automatically when the output shift register is emptied, i.e. on or
     * following an OUT instruction which causes the output shift counter to
     * reach or exceed PULL_THRESH.
     */
    inline bool get_SHIFTCTRL_AUTOPULL()
    {
        return SHIFTCTRL & (1u << 17u);
    }

    /**
     * Set SHIFTCTRL's AUTOPULL bit.
     *
     * Pull automatically when the output shift register is emptied, i.e. on or
     * following an OUT instruction which causes the output shift counter to
     * reach or exceed PULL_THRESH.
     */
    inline void set_SHIFTCTRL_AUTOPULL()
    {
        SHIFTCTRL |= 1u << 17u;
    }

    /**
     * Clear SHIFTCTRL's AUTOPULL bit.
     *
     * Pull automatically when the output shift register is emptied, i.e. on or
     * following an OUT instruction which causes the output shift counter to
     * reach or exceed PULL_THRESH.
     */
    inline void clear_SHIFTCTRL_AUTOPULL()
    {
        SHIFTCTRL &= ~(1u << 17u);
    }

    /**
     * Toggle SHIFTCTRL's AUTOPULL bit.
     *
     * Pull automatically when the output shift register is emptied, i.e. on or
     * following an OUT instruction which causes the output shift counter to
     * reach or exceed PULL_THRESH.
     */
    inline void toggle_SHIFTCTRL_AUTOPULL()
    {
        SHIFTCTRL ^= 1u << 17u;
    }

    /**
     * Get SHIFTCTRL's IN_SHIFTDIR bit.
     *
     * 1 = shift input shift register to right (data enters from left). 0 = to
     * left.
     */
    inline bool get_SHIFTCTRL_IN_SHIFTDIR()
    {
        return SHIFTCTRL & (1u << 18u);
    }

    /**
     * Set SHIFTCTRL's IN_SHIFTDIR bit.
     *
     * 1 = shift input shift register to right (data enters from left). 0 = to
     * left.
     */
    inline void set_SHIFTCTRL_IN_SHIFTDIR()
    {
        SHIFTCTRL |= 1u << 18u;
    }

    /**
     * Clear SHIFTCTRL's IN_SHIFTDIR bit.
     *
     * 1 = shift input shift register to right (data enters from left). 0 = to
     * left.
     */
    inline void clear_SHIFTCTRL_IN_SHIFTDIR()
    {
        SHIFTCTRL &= ~(1u << 18u);
    }

    /**
     * Toggle SHIFTCTRL's IN_SHIFTDIR bit.
     *
     * 1 = shift input shift register to right (data enters from left). 0 = to
     * left.
     */
    inline void toggle_SHIFTCTRL_IN_SHIFTDIR()
    {
        SHIFTCTRL ^= 1u << 18u;
    }

    /**
     * Get SHIFTCTRL's OUT_SHIFTDIR bit.
     *
     * 1 = shift out of output shift register to right. 0 = to left.
     */
    inline bool get_SHIFTCTRL_OUT_SHIFTDIR()
    {
        return SHIFTCTRL & (1u << 19u);
    }

    /**
     * Set SHIFTCTRL's OUT_SHIFTDIR bit.
     *
     * 1 = shift out of output shift register to right. 0 = to left.
     */
    inline void set_SHIFTCTRL_OUT_SHIFTDIR()
    {
        SHIFTCTRL |= 1u << 19u;
    }

    /**
     * Clear SHIFTCTRL's OUT_SHIFTDIR bit.
     *
     * 1 = shift out of output shift register to right. 0 = to left.
     */
    inline void clear_SHIFTCTRL_OUT_SHIFTDIR()
    {
        SHIFTCTRL &= ~(1u << 19u);
    }

    /**
     * Toggle SHIFTCTRL's OUT_SHIFTDIR bit.
     *
     * 1 = shift out of output shift register to right. 0 = to left.
     */
    inline void toggle_SHIFTCTRL_OUT_SHIFTDIR()
    {
        SHIFTCTRL ^= 1u << 19u;
    }

    /**
     * Get SHIFTCTRL's PUSH_THRESH field.
     *
     * Number of bits shifted into ISR before autopush, or conditional push
     * (PUSH IFFULL), will take place. Write 0 for value of 32.
     */
    inline uint8_t get_SHIFTCTRL_PUSH_THRESH()
    {
        return (SHIFTCTRL >> 20u) & 0b11111u;
    }

    /**
     * Set SHIFTCTRL's PUSH_THRESH field.
     *
     * Number of bits shifted into ISR before autopush, or conditional push
     * (PUSH IFFULL), will take place. Write 0 for value of 32.
     */
    inline void set_SHIFTCTRL_PUSH_THRESH(uint8_t value)
    {
        uint32_t curr = SHIFTCTRL;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        SHIFTCTRL = curr;
    }

    /**
     * Get SHIFTCTRL's PULL_THRESH field.
     *
     * Number of bits shifted out of OSR before autopull, or conditional pull
     * (PULL IFEMPTY), will take place. Write 0 for value of 32.
     */
    inline uint8_t get_SHIFTCTRL_PULL_THRESH()
    {
        return (SHIFTCTRL >> 25u) & 0b11111u;
    }

    /**
     * Set SHIFTCTRL's PULL_THRESH field.
     *
     * Number of bits shifted out of OSR before autopull, or conditional pull
     * (PULL IFEMPTY), will take place. Write 0 for value of 32.
     */
    inline void set_SHIFTCTRL_PULL_THRESH(uint8_t value)
    {
        uint32_t curr = SHIFTCTRL;

        curr &= ~(0b11111u << 25u);
        curr |= (value & 0b11111u) << 25u;

        SHIFTCTRL = curr;
    }

    /**
     * Get SHIFTCTRL's FJOIN_TX bit.
     *
     * When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.
     *                 RX FIFO is disabled as a result (always reads as both
     * full and empty). FIFOs are flushed when this bit is changed.
     */
    inline bool get_SHIFTCTRL_FJOIN_TX()
    {
        return SHIFTCTRL & (1u << 30u);
    }

    /**
     * Set SHIFTCTRL's FJOIN_TX bit.
     *
     * When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.
     *                 RX FIFO is disabled as a result (always reads as both
     * full and empty). FIFOs are flushed when this bit is changed.
     */
    inline void set_SHIFTCTRL_FJOIN_TX()
    {
        SHIFTCTRL |= 1u << 30u;
    }

    /**
     * Clear SHIFTCTRL's FJOIN_TX bit.
     *
     * When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.
     *                 RX FIFO is disabled as a result (always reads as both
     * full and empty). FIFOs are flushed when this bit is changed.
     */
    inline void clear_SHIFTCTRL_FJOIN_TX()
    {
        SHIFTCTRL &= ~(1u << 30u);
    }

    /**
     * Toggle SHIFTCTRL's FJOIN_TX bit.
     *
     * When 1, TX FIFO steals the RX FIFO's storage, and becomes twice as deep.
     *                 RX FIFO is disabled as a result (always reads as both
     * full and empty). FIFOs are flushed when this bit is changed.
     */
    inline void toggle_SHIFTCTRL_FJOIN_TX()
    {
        SHIFTCTRL ^= 1u << 30u;
    }

    /**
     * Get SHIFTCTRL's FJOIN_RX bit.
     *
     * When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.
     *                 TX FIFO is disabled as a result (always reads as both
     * full and empty). FIFOs are flushed when this bit is changed.
     */
    inline bool get_SHIFTCTRL_FJOIN_RX()
    {
        return SHIFTCTRL & (1u << 31u);
    }

    /**
     * Set SHIFTCTRL's FJOIN_RX bit.
     *
     * When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.
     *                 TX FIFO is disabled as a result (always reads as both
     * full and empty). FIFOs are flushed when this bit is changed.
     */
    inline void set_SHIFTCTRL_FJOIN_RX()
    {
        SHIFTCTRL |= 1u << 31u;
    }

    /**
     * Clear SHIFTCTRL's FJOIN_RX bit.
     *
     * When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.
     *                 TX FIFO is disabled as a result (always reads as both
     * full and empty). FIFOs are flushed when this bit is changed.
     */
    inline void clear_SHIFTCTRL_FJOIN_RX()
    {
        SHIFTCTRL &= ~(1u << 31u);
    }

    /**
     * Toggle SHIFTCTRL's FJOIN_RX bit.
     *
     * When 1, RX FIFO steals the TX FIFO's storage, and becomes twice as deep.
     *                 TX FIFO is disabled as a result (always reads as both
     * full and empty). FIFOs are flushed when this bit is changed.
     */
    inline void toggle_SHIFTCTRL_FJOIN_RX()
    {
        SHIFTCTRL ^= 1u << 31u;
    }

    /**
     * Get all of SHIFTCTRL's bit fields.
     *
     * (read-write) Control behaviour of the input/output shift registers for
     * state machine N
     */
    inline void get_SHIFTCTRL(bool &AUTOPUSH, bool &AUTOPULL,
                              bool &IN_SHIFTDIR, bool &OUT_SHIFTDIR,
                              uint8_t &PUSH_THRESH, uint8_t &PULL_THRESH,
                              bool &FJOIN_TX, bool &FJOIN_RX)
    {
        uint32_t curr = SHIFTCTRL;

        AUTOPUSH = curr & (1u << 16u);
        AUTOPULL = curr & (1u << 17u);
        IN_SHIFTDIR = curr & (1u << 18u);
        OUT_SHIFTDIR = curr & (1u << 19u);
        PUSH_THRESH = (curr >> 20u) & 0b11111u;
        PULL_THRESH = (curr >> 25u) & 0b11111u;
        FJOIN_TX = curr & (1u << 30u);
        FJOIN_RX = curr & (1u << 31u);
    }

    /**
     * Set all of SHIFTCTRL's bit fields.
     *
     * (read-write) Control behaviour of the input/output shift registers for
     * state machine N
     */
    inline void set_SHIFTCTRL(bool AUTOPUSH, bool AUTOPULL, bool IN_SHIFTDIR,
                              bool OUT_SHIFTDIR, uint8_t PUSH_THRESH,
                              uint8_t PULL_THRESH, bool FJOIN_TX,
                              bool FJOIN_RX)
    {
        uint32_t curr = SHIFTCTRL;

        curr &= ~(0b1u << 16u);
        curr |= (AUTOPUSH & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (AUTOPULL & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (IN_SHIFTDIR & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (OUT_SHIFTDIR & 0b1u) << 19u;
        curr &= ~(0b11111u << 20u);
        curr |= (PUSH_THRESH & 0b11111u) << 20u;
        curr &= ~(0b11111u << 25u);
        curr |= (PULL_THRESH & 0b11111u) << 25u;
        curr &= ~(0b1u << 30u);
        curr |= (FJOIN_TX & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FJOIN_RX & 0b1u) << 31u;

        SHIFTCTRL = curr;
    }

    /**
     * Get ADDR's ADDR field.
     */
    inline uint8_t get_ADDR()
    {
        return ADDR & 0b11111u;
    }

    /**
     * Get INSTR's INSTR field.
     */
    inline uint16_t get_INSTR()
    {
        return INSTR & 0xffffu;
    }

    /**
     * Set INSTR's INSTR field.
     */
    inline void set_INSTR(uint16_t value)
    {
        uint32_t curr = INSTR;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        INSTR = curr;
    }

    /**
     * Get PINCTRL's OUT_BASE field.
     *
     * The lowest-numbered pin that will be affected by an OUT PINS, OUT
     * PINDIRS or MOV PINS instruction. The data written to this pin will
     * always be the least-significant bit of the OUT or MOV data.
     */
    inline uint8_t get_PINCTRL_OUT_BASE()
    {
        return PINCTRL & 0b11111u;
    }

    /**
     * Set PINCTRL's OUT_BASE field.
     *
     * The lowest-numbered pin that will be affected by an OUT PINS, OUT
     * PINDIRS or MOV PINS instruction. The data written to this pin will
     * always be the least-significant bit of the OUT or MOV data.
     */
    inline void set_PINCTRL_OUT_BASE(uint8_t value)
    {
        uint32_t curr = PINCTRL;

        curr &= ~(0b11111u);
        curr |= (value & 0b11111u);

        PINCTRL = curr;
    }

    /**
     * Get PINCTRL's SET_BASE field.
     *
     * The lowest-numbered pin that will be affected by a SET PINS or SET
     * PINDIRS instruction. The data written to this pin is the
     * least-significant bit of the SET data.
     */
    inline uint8_t get_PINCTRL_SET_BASE()
    {
        return (PINCTRL >> 5u) & 0b11111u;
    }

    /**
     * Set PINCTRL's SET_BASE field.
     *
     * The lowest-numbered pin that will be affected by a SET PINS or SET
     * PINDIRS instruction. The data written to this pin is the
     * least-significant bit of the SET data.
     */
    inline void set_PINCTRL_SET_BASE(uint8_t value)
    {
        uint32_t curr = PINCTRL;

        curr &= ~(0b11111u << 5u);
        curr |= (value & 0b11111u) << 5u;

        PINCTRL = curr;
    }

    /**
     * Get PINCTRL's SIDESET_BASE field.
     *
     * The lowest-numbered pin that will be affected by a side-set operation.
     * The MSBs of an instruction's side-set/delay field (up to 5, determined
     * by SIDESET_COUNT) are used for side-set data, with the remaining LSBs
     * used for delay. The least-significant bit of the side-set portion is the
     * bit written to this pin, with more-significant bits written to
     * higher-numbered pins.
     */
    inline uint8_t get_PINCTRL_SIDESET_BASE()
    {
        return (PINCTRL >> 10u) & 0b11111u;
    }

    /**
     * Set PINCTRL's SIDESET_BASE field.
     *
     * The lowest-numbered pin that will be affected by a side-set operation.
     * The MSBs of an instruction's side-set/delay field (up to 5, determined
     * by SIDESET_COUNT) are used for side-set data, with the remaining LSBs
     * used for delay. The least-significant bit of the side-set portion is the
     * bit written to this pin, with more-significant bits written to
     * higher-numbered pins.
     */
    inline void set_PINCTRL_SIDESET_BASE(uint8_t value)
    {
        uint32_t curr = PINCTRL;

        curr &= ~(0b11111u << 10u);
        curr |= (value & 0b11111u) << 10u;

        PINCTRL = curr;
    }

    /**
     * Get PINCTRL's IN_BASE field.
     *
     * The pin which is mapped to the least-significant bit of a state
     * machine's IN data bus. Higher-numbered pins are mapped to consecutively
     * more-significant data bits, with a modulo of 32 applied to pin number.
     */
    inline uint8_t get_PINCTRL_IN_BASE()
    {
        return (PINCTRL >> 15u) & 0b11111u;
    }

    /**
     * Set PINCTRL's IN_BASE field.
     *
     * The pin which is mapped to the least-significant bit of a state
     * machine's IN data bus. Higher-numbered pins are mapped to consecutively
     * more-significant data bits, with a modulo of 32 applied to pin number.
     */
    inline void set_PINCTRL_IN_BASE(uint8_t value)
    {
        uint32_t curr = PINCTRL;

        curr &= ~(0b11111u << 15u);
        curr |= (value & 0b11111u) << 15u;

        PINCTRL = curr;
    }

    /**
     * Get PINCTRL's OUT_COUNT field.
     *
     * The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS
     * instruction. In the range 0 to 32 inclusive.
     */
    inline uint8_t get_PINCTRL_OUT_COUNT()
    {
        return (PINCTRL >> 20u) & 0b111111u;
    }

    /**
     * Set PINCTRL's OUT_COUNT field.
     *
     * The number of pins asserted by an OUT PINS, OUT PINDIRS or MOV PINS
     * instruction. In the range 0 to 32 inclusive.
     */
    inline void set_PINCTRL_OUT_COUNT(uint8_t value)
    {
        uint32_t curr = PINCTRL;

        curr &= ~(0b111111u << 20u);
        curr |= (value & 0b111111u) << 20u;

        PINCTRL = curr;
    }

    /**
     * Get PINCTRL's SET_COUNT field.
     *
     * The number of pins asserted by a SET. In the range 0 to 5 inclusive.
     */
    inline uint8_t get_PINCTRL_SET_COUNT()
    {
        return (PINCTRL >> 26u) & 0b111u;
    }

    /**
     * Set PINCTRL's SET_COUNT field.
     *
     * The number of pins asserted by a SET. In the range 0 to 5 inclusive.
     */
    inline void set_PINCTRL_SET_COUNT(uint8_t value)
    {
        uint32_t curr = PINCTRL;

        curr &= ~(0b111u << 26u);
        curr |= (value & 0b111u) << 26u;

        PINCTRL = curr;
    }

    /**
     * Get PINCTRL's SIDESET_COUNT field.
     *
     * The number of MSBs of the Delay/Side-set instruction field which are
     * used for side-set. Inclusive of the enable bit, if present. Minimum of 0
     * (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
     */
    inline uint8_t get_PINCTRL_SIDESET_COUNT()
    {
        return (PINCTRL >> 29u) & 0b111u;
    }

    /**
     * Set PINCTRL's SIDESET_COUNT field.
     *
     * The number of MSBs of the Delay/Side-set instruction field which are
     * used for side-set. Inclusive of the enable bit, if present. Minimum of 0
     * (all delay bits, no side-set) and maximum of 5 (all side-set, no delay).
     */
    inline void set_PINCTRL_SIDESET_COUNT(uint8_t value)
    {
        uint32_t curr = PINCTRL;

        curr &= ~(0b111u << 29u);
        curr |= (value & 0b111u) << 29u;

        PINCTRL = curr;
    }

    /**
     * Get all of PINCTRL's bit fields.
     *
     * (read-write) State machine pin control
     */
    inline void get_PINCTRL(uint8_t &OUT_BASE, uint8_t &SET_BASE,
                            uint8_t &SIDESET_BASE, uint8_t &IN_BASE,
                            uint8_t &OUT_COUNT, uint8_t &SET_COUNT,
                            uint8_t &SIDESET_COUNT)
    {
        uint32_t curr = PINCTRL;

        OUT_BASE = curr & 0b11111u;
        SET_BASE = (curr >> 5u) & 0b11111u;
        SIDESET_BASE = (curr >> 10u) & 0b11111u;
        IN_BASE = (curr >> 15u) & 0b11111u;
        OUT_COUNT = (curr >> 20u) & 0b111111u;
        SET_COUNT = (curr >> 26u) & 0b111u;
        SIDESET_COUNT = (curr >> 29u) & 0b111u;
    }

    /**
     * Set all of PINCTRL's bit fields.
     *
     * (read-write) State machine pin control
     */
    inline void set_PINCTRL(uint8_t OUT_BASE, uint8_t SET_BASE,
                            uint8_t SIDESET_BASE, uint8_t IN_BASE,
                            uint8_t OUT_COUNT, uint8_t SET_COUNT,
                            uint8_t SIDESET_COUNT)
    {
        uint32_t curr = PINCTRL;

        curr &= ~(0b11111u);
        curr |= (OUT_BASE & 0b11111u);
        curr &= ~(0b11111u << 5u);
        curr |= (SET_BASE & 0b11111u) << 5u;
        curr &= ~(0b11111u << 10u);
        curr |= (SIDESET_BASE & 0b11111u) << 10u;
        curr &= ~(0b11111u << 15u);
        curr |= (IN_BASE & 0b11111u) << 15u;
        curr &= ~(0b111111u << 20u);
        curr |= (OUT_COUNT & 0b111111u) << 20u;
        curr &= ~(0b111u << 26u);
        curr |= (SET_COUNT & 0b111u) << 26u;
        curr &= ~(0b111u << 29u);
        curr |= (SIDESET_COUNT & 0b111u) << 29u;

        PINCTRL = curr;
    }
};

static_assert(sizeof(pio_sm) == pio_sm::size);
static_assert(ifgen_struct<pio_sm>);

}; // namespace RP2040

#endif
