/**
 * \file
 * \brief Generated by ifgen (4.7.1).
 */

#pragma once
#ifndef RP2040_STRUCTS_BUSCTRL_H
#define RP2040_STRUCTS_BUSCTRL_H

#include "../enums/BUSCTRL_PERFSEL.h"
#include "../ifgen/common.h"

namespace RP2040
{

/**
 * Register block for busfabric control signals and performance counters
 */
struct busctrl
{
    /* Constant attributes. */
    static constexpr struct_id_t id = 2;    /*!< busctrl's identifier. */
    static constexpr std::size_t size = 40; /*!< busctrl's size in bytes. */

    /* Fields. */
    uint32_t BUS_PRIORITY; /*!< (read-write) Set the priority of each master
                              for bus arbitration. */
    const uint32_t BUS_PRIORITY_ACK =
        {};            /*!< (read-only) Bus priority acknowledge */
    uint32_t PERFCTR0; /*!< (read-write) Bus fabric performance counter 0 */
    uint32_t PERFSEL0; /*!< (read-write) Bus fabric performance event select
                          for PERFCTR0 */
    uint32_t PERFCTR1; /*!< (read-write) Bus fabric performance counter 1 */
    uint32_t PERFSEL1; /*!< (read-write) Bus fabric performance event select
                          for PERFCTR1 */
    uint32_t PERFCTR2; /*!< (read-write) Bus fabric performance counter 2 */
    uint32_t PERFSEL2; /*!< (read-write) Bus fabric performance event select
                          for PERFCTR2 */
    uint32_t PERFCTR3; /*!< (read-write) Bus fabric performance counter 3 */
    uint32_t PERFSEL3; /*!< (read-write) Bus fabric performance event select
                          for PERFCTR3 */

    /* Methods. */

    /**
     * Get BUS_PRIORITY's PROC0 bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline bool get_BUS_PRIORITY_PROC0() volatile
    {
        return BUS_PRIORITY & 1u;
    }

    /**
     * Set BUS_PRIORITY's PROC0 bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void set_BUS_PRIORITY_PROC0() volatile
    {
        BUS_PRIORITY |= 1u;
    }

    /**
     * Clear BUS_PRIORITY's PROC0 bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void clear_BUS_PRIORITY_PROC0() volatile
    {
        BUS_PRIORITY &= ~(1u);
    }

    /**
     * Toggle BUS_PRIORITY's PROC0 bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void toggle_BUS_PRIORITY_PROC0() volatile
    {
        BUS_PRIORITY ^= 1u;
    }

    /**
     * Get BUS_PRIORITY's PROC1 bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline bool get_BUS_PRIORITY_PROC1() volatile
    {
        return BUS_PRIORITY & (1u << 4u);
    }

    /**
     * Set BUS_PRIORITY's PROC1 bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void set_BUS_PRIORITY_PROC1() volatile
    {
        BUS_PRIORITY |= 1u << 4u;
    }

    /**
     * Clear BUS_PRIORITY's PROC1 bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void clear_BUS_PRIORITY_PROC1() volatile
    {
        BUS_PRIORITY &= ~(1u << 4u);
    }

    /**
     * Toggle BUS_PRIORITY's PROC1 bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void toggle_BUS_PRIORITY_PROC1() volatile
    {
        BUS_PRIORITY ^= 1u << 4u;
    }

    /**
     * Get BUS_PRIORITY's DMA_R bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline bool get_BUS_PRIORITY_DMA_R() volatile
    {
        return BUS_PRIORITY & (1u << 8u);
    }

    /**
     * Set BUS_PRIORITY's DMA_R bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void set_BUS_PRIORITY_DMA_R() volatile
    {
        BUS_PRIORITY |= 1u << 8u;
    }

    /**
     * Clear BUS_PRIORITY's DMA_R bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void clear_BUS_PRIORITY_DMA_R() volatile
    {
        BUS_PRIORITY &= ~(1u << 8u);
    }

    /**
     * Toggle BUS_PRIORITY's DMA_R bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void toggle_BUS_PRIORITY_DMA_R() volatile
    {
        BUS_PRIORITY ^= 1u << 8u;
    }

    /**
     * Get BUS_PRIORITY's DMA_W bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline bool get_BUS_PRIORITY_DMA_W() volatile
    {
        return BUS_PRIORITY & (1u << 12u);
    }

    /**
     * Set BUS_PRIORITY's DMA_W bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void set_BUS_PRIORITY_DMA_W() volatile
    {
        BUS_PRIORITY |= 1u << 12u;
    }

    /**
     * Clear BUS_PRIORITY's DMA_W bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void clear_BUS_PRIORITY_DMA_W() volatile
    {
        BUS_PRIORITY &= ~(1u << 12u);
    }

    /**
     * Toggle BUS_PRIORITY's DMA_W bit.
     *
     * 0 - low priority, 1 - high priority
     */
    inline void toggle_BUS_PRIORITY_DMA_W() volatile
    {
        BUS_PRIORITY ^= 1u << 12u;
    }

    /**
     * Get all of BUS_PRIORITY's bit fields.
     *
     * (read-write) Set the priority of each master for bus arbitration.
     */
    inline void get_BUS_PRIORITY(bool &PROC0, bool &PROC1, bool &DMA_R,
                                 bool &DMA_W) volatile
    {
        uint32_t curr = BUS_PRIORITY;

        PROC0 = curr & 1u;
        PROC1 = curr & (1u << 4u);
        DMA_R = curr & (1u << 8u);
        DMA_W = curr & (1u << 12u);
    }

    /**
     * Set all of BUS_PRIORITY's bit fields.
     *
     * (read-write) Set the priority of each master for bus arbitration.
     */
    inline void set_BUS_PRIORITY(bool PROC0, bool PROC1, bool DMA_R,
                                 bool DMA_W) volatile
    {
        uint32_t curr = BUS_PRIORITY;

        curr &= ~(0b1u);
        curr |= (PROC0 & 0b1u);
        curr &= ~(0b1u << 4u);
        curr |= (PROC1 & 0b1u) << 4u;
        curr &= ~(0b1u << 8u);
        curr |= (DMA_R & 0b1u) << 8u;
        curr &= ~(0b1u << 12u);
        curr |= (DMA_W & 0b1u) << 12u;

        BUS_PRIORITY = curr;
    }

    /**
     * Get BUS_PRIORITY_ACK's BUS_PRIORITY_ACK bit.
     *
     * Goes to 1 once all arbiters have registered the new global priority
     * levels. Arbiters update their local priority when servicing a new
     * nonsequential access. In normal circumstances this will happen almost
     * immediately.
     */
    inline bool get_BUS_PRIORITY_ACK() volatile
    {
        return BUS_PRIORITY_ACK & 1u;
    }

    /**
     * Get PERFCTR0's PERFCTR0 field.
     *
     * Busfabric saturating performance counter 0
     *                 Count some event signal from the busfabric arbiters.
     *                 Write any value to clear. Select an event to count using
     * PERFSEL0
     */
    inline uint32_t get_PERFCTR0() volatile
    {
        return PERFCTR0 & 0xffffffu;
    }

    /**
     * Set PERFCTR0's PERFCTR0 field.
     *
     * Busfabric saturating performance counter 0
     *                 Count some event signal from the busfabric arbiters.
     *                 Write any value to clear. Select an event to count using
     * PERFSEL0
     */
    inline void set_PERFCTR0(uint32_t value) volatile
    {
        uint32_t curr = PERFCTR0;

        curr &= ~(0xffffffu);
        curr |= (value & 0xffffffu);

        PERFCTR0 = curr;
    }

    /**
     * Get PERFSEL0's PERFSEL0 field.
     *
     * Select an event for PERFCTR0. Count either contested accesses, or all
     * accesses, on a downstream port of the main crossbar.
     */
    inline BUSCTRL_PERFSEL get_PERFSEL0() volatile
    {
        return BUSCTRL_PERFSEL(PERFSEL0 & 0b11111u);
    }

    /**
     * Set PERFSEL0's PERFSEL0 field.
     *
     * Select an event for PERFCTR0. Count either contested accesses, or all
     * accesses, on a downstream port of the main crossbar.
     */
    inline void set_PERFSEL0(BUSCTRL_PERFSEL value) volatile
    {
        uint32_t curr = PERFSEL0;

        curr &= ~(0b11111u);
        curr |= (std::to_underlying(value) & 0b11111u);

        PERFSEL0 = curr;
    }

    /**
     * Get PERFCTR1's PERFCTR1 field.
     *
     * Busfabric saturating performance counter 1
     *                 Count some event signal from the busfabric arbiters.
     *                 Write any value to clear. Select an event to count using
     * PERFSEL1
     */
    inline uint32_t get_PERFCTR1() volatile
    {
        return PERFCTR1 & 0xffffffu;
    }

    /**
     * Set PERFCTR1's PERFCTR1 field.
     *
     * Busfabric saturating performance counter 1
     *                 Count some event signal from the busfabric arbiters.
     *                 Write any value to clear. Select an event to count using
     * PERFSEL1
     */
    inline void set_PERFCTR1(uint32_t value) volatile
    {
        uint32_t curr = PERFCTR1;

        curr &= ~(0xffffffu);
        curr |= (value & 0xffffffu);

        PERFCTR1 = curr;
    }

    /**
     * Get PERFSEL1's PERFSEL1 field.
     *
     * Select an event for PERFCTR1. Count either contested accesses, or all
     * accesses, on a downstream port of the main crossbar.
     */
    inline BUSCTRL_PERFSEL get_PERFSEL1() volatile
    {
        return BUSCTRL_PERFSEL(PERFSEL1 & 0b11111u);
    }

    /**
     * Set PERFSEL1's PERFSEL1 field.
     *
     * Select an event for PERFCTR1. Count either contested accesses, or all
     * accesses, on a downstream port of the main crossbar.
     */
    inline void set_PERFSEL1(BUSCTRL_PERFSEL value) volatile
    {
        uint32_t curr = PERFSEL1;

        curr &= ~(0b11111u);
        curr |= (std::to_underlying(value) & 0b11111u);

        PERFSEL1 = curr;
    }

    /**
     * Get PERFCTR2's PERFCTR2 field.
     *
     * Busfabric saturating performance counter 2
     *                 Count some event signal from the busfabric arbiters.
     *                 Write any value to clear. Select an event to count using
     * PERFSEL2
     */
    inline uint32_t get_PERFCTR2() volatile
    {
        return PERFCTR2 & 0xffffffu;
    }

    /**
     * Set PERFCTR2's PERFCTR2 field.
     *
     * Busfabric saturating performance counter 2
     *                 Count some event signal from the busfabric arbiters.
     *                 Write any value to clear. Select an event to count using
     * PERFSEL2
     */
    inline void set_PERFCTR2(uint32_t value) volatile
    {
        uint32_t curr = PERFCTR2;

        curr &= ~(0xffffffu);
        curr |= (value & 0xffffffu);

        PERFCTR2 = curr;
    }

    /**
     * Get PERFSEL2's PERFSEL2 field.
     *
     * Select an event for PERFCTR2. Count either contested accesses, or all
     * accesses, on a downstream port of the main crossbar.
     */
    inline BUSCTRL_PERFSEL get_PERFSEL2() volatile
    {
        return BUSCTRL_PERFSEL(PERFSEL2 & 0b11111u);
    }

    /**
     * Set PERFSEL2's PERFSEL2 field.
     *
     * Select an event for PERFCTR2. Count either contested accesses, or all
     * accesses, on a downstream port of the main crossbar.
     */
    inline void set_PERFSEL2(BUSCTRL_PERFSEL value) volatile
    {
        uint32_t curr = PERFSEL2;

        curr &= ~(0b11111u);
        curr |= (std::to_underlying(value) & 0b11111u);

        PERFSEL2 = curr;
    }

    /**
     * Get PERFCTR3's PERFCTR3 field.
     *
     * Busfabric saturating performance counter 3
     *                 Count some event signal from the busfabric arbiters.
     *                 Write any value to clear. Select an event to count using
     * PERFSEL3
     */
    inline uint32_t get_PERFCTR3() volatile
    {
        return PERFCTR3 & 0xffffffu;
    }

    /**
     * Set PERFCTR3's PERFCTR3 field.
     *
     * Busfabric saturating performance counter 3
     *                 Count some event signal from the busfabric arbiters.
     *                 Write any value to clear. Select an event to count using
     * PERFSEL3
     */
    inline void set_PERFCTR3(uint32_t value) volatile
    {
        uint32_t curr = PERFCTR3;

        curr &= ~(0xffffffu);
        curr |= (value & 0xffffffu);

        PERFCTR3 = curr;
    }

    /**
     * Get PERFSEL3's PERFSEL3 field.
     *
     * Select an event for PERFCTR3. Count either contested accesses, or all
     * accesses, on a downstream port of the main crossbar.
     */
    inline BUSCTRL_PERFSEL get_PERFSEL3() volatile
    {
        return BUSCTRL_PERFSEL(PERFSEL3 & 0b11111u);
    }

    /**
     * Set PERFSEL3's PERFSEL3 field.
     *
     * Select an event for PERFCTR3. Count either contested accesses, or all
     * accesses, on a downstream port of the main crossbar.
     */
    inline void set_PERFSEL3(BUSCTRL_PERFSEL value) volatile
    {
        uint32_t curr = PERFSEL3;

        curr &= ~(0b11111u);
        curr |= (std::to_underlying(value) & 0b11111u);

        PERFSEL3 = curr;
    }
};

static_assert(sizeof(busctrl) == busctrl::size);
static_assert(ifgen_struct<busctrl>);

static volatile busctrl *const BUSCTRL =
    reinterpret_cast<busctrl *>(0x40030000);

}; // namespace RP2040

#endif
