/**
 * \file
 * \brief Generated by ifgen (4.7.3).
 */

#pragma once
#ifndef RP2040_STRUCTS_PIO_H
#define RP2040_STRUCTS_PIO_H

#include "../ifgen/common.h"
#include "pio_interrupt_cluster.h"
#include "pio_sm.h"

namespace RP2040
{

/**
 * Programmable IO block
 */
struct pio
{
    /* Constant attributes. */
    static constexpr struct_id_t id = 14;    /*!< pio's identifier. */
    static constexpr std::size_t size = 324; /*!< pio's size in bytes. */

    /* Fields. */
    uint32_t CTRL;              /*!< (read-write) PIO control register */
    const uint32_t FSTAT = {};  /*!< (read-only) FIFO status register */
    uint32_t FDEBUG;            /*!< (read-write) FIFO debug register */
    const uint32_t FLEVEL = {}; /*!< (read-only) FIFO levels */
    static constexpr std::size_t TXF_length = 4;
    uint32_t TXF[TXF_length]; /*!< (read-write) Direct write access to the TX
                                 FIFO for this state machine. Each write pushes
                                 one word to the FIFO. Attempting to write to a
                                 full FIFO has no effect on the FIFO state or
                                 contents, and sets the sticky FDEBUG_TXOVER
                                 error flag for this FIFO. */
    static constexpr std::size_t RXF_length = 4;
    uint32_t
        RXF[RXF_length]; /*!< (read-write) Direct read access to the RX FIFO
                            for this state machine. Each read pops one word
                            from the FIFO. Attempting to read from an empty
                            FIFO has no effect on the FIFO state, and sets the
                            sticky FDEBUG_RXUNDER error flag for this FIFO. The
                            data returned to the system on a read from an empty
                            FIFO is undefined. */
    uint32_t IRQ; /*!< (read-write) State machine IRQ flags register. Write 1
to clear. There are 8 state machine IRQ flags, which can be set, cleared, and
waited on by the state machines. There's no fixed association between flags and
state machines -- any state machine can use any flag. Any of the 8 flags can be
used for timing synchronisation between state machines, using IRQ and WAIT
instructions. The lower four of these flags are also routed out to system-level
interrupt requests, alongside FIFO status interrupts -- see e.g. IRQ0_INTE. */
    uint32_t IRQ_FORCE; /*!< (write-only) Writing a 1 to each of these bits
                           will forcibly assert the corresponding IRQ. Note
                           this is different to the INTF register: writing here
                           affects PIO internal state. INTF just asserts the
                           processor-facing IRQ signal for testing ISRs, and is
                           not visible to the state machines. */
    uint32_t INPUT_SYNC_BYPASS; /*!< (read-write) There is a 2-flipflop
synchronizer on each GPIO input, which protects PIO logic from metastabilities.
This increases input delay, and for fast synchronous IO (e.g. SPI) these
synchronizers may need to be bypassed. Each bit in this register corresponds to
one GPIO. 0 -> input is synchronized (default) 1 -> synchronizer is bypassed If
in doubt, leave this register as all zeroes. */
    uint32_t DBG_PADOUT; /*!< (read-write) Read to sample the pad output values
                            PIO is currently driving to the GPIOs. On RP2040
                            there are 30 GPIOs, so the two most significant
                            bits are hardwired to 0. */
    uint32_t DBG_PADOE; /*!< (read-write) Read to sample the pad output enables
                           (direction) PIO is currently driving to the GPIOs.
                           On RP2040 there are 30 GPIOs, so the two most
                           significant bits are hardwired to 0. */
    const uint32_t DBG_CFGINFO = {}; /*!< (read-only) The PIO hardware has some
free parameters that may vary between chip products. These should be provided
in the chip datasheet, but are also exposed here. */
    static constexpr std::size_t INSTR_MEM_length = 32;
    uint32_t
        INSTR_MEM[INSTR_MEM_length]; /*!< (write-only) Write-only access to
                                        instruction memory location N */
    static constexpr std::size_t SM_length = 4;
    pio_sm SM[SM_length];
    const uint32_t INTR = {}; /*!< (read-only) Raw Interrupts */
    static constexpr std::size_t IRQS_length = 2;
    pio_interrupt_cluster IRQS[IRQS_length];

    /* Methods. */

    /**
     * Get CTRL's SM_ENABLE field.
     *
     * Enable/disable each of the four state machines by writing 1/0 to each of
     * these four bits. When disabled, a state machine will cease executing
     * instructions, except those written directly to SMx_INSTR by the system.
     * Multiple bits can be set/cleared at once to run/halt multiple state
     * machines simultaneously.
     */
    inline uint8_t get_CTRL_SM_ENABLE() volatile
    {
        return CTRL & 0xfu;
    }

    /**
     * Set CTRL's SM_ENABLE field.
     *
     * Enable/disable each of the four state machines by writing 1/0 to each of
     * these four bits. When disabled, a state machine will cease executing
     * instructions, except those written directly to SMx_INSTR by the system.
     * Multiple bits can be set/cleared at once to run/halt multiple state
     * machines simultaneously.
     */
    inline void set_CTRL_SM_ENABLE(uint8_t value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0xfu);
        curr |= (value & 0xfu);

        CTRL = curr;
    }

    /**
     * Get CTRL's SM_RESTART field.
     *
     * Write 1 to instantly clear internal SM state which may be otherwise
     * difficult to access and will affect future execution. Specifically, the
     * following are cleared: input and output shift counters; the contents of
     * the input shift register; the delay counter; the waiting-on-IRQ state;
     * any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any
     * pin write left asserted due to OUT_STICKY. The program counter, the
     * contents of the output shift register and the X/Y scratch registers are
     * not affected.
     */
    inline uint8_t get_CTRL_SM_RESTART() volatile
    {
        return (CTRL >> 4u) & 0xfu;
    }

    /**
     * Set CTRL's SM_RESTART field.
     *
     * Write 1 to instantly clear internal SM state which may be otherwise
     * difficult to access and will affect future execution. Specifically, the
     * following are cleared: input and output shift counters; the contents of
     * the input shift register; the delay counter; the waiting-on-IRQ state;
     * any stalled instruction written to SMx_INSTR or run by OUT/MOV EXEC; any
     * pin write left asserted due to OUT_STICKY. The program counter, the
     * contents of the output shift register and the X/Y scratch registers are
     * not affected.
     */
    inline void set_CTRL_SM_RESTART(uint8_t value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0xfu << 4u);
        curr |= (value & 0xfu) << 4u;

        CTRL = curr;
    }

    /**
     * Get CTRL's CLKDIV_RESTART field.
     *
     * Restart a state machine's clock divider from an initial phase of 0.
     * Clock dividers are free-running, so once started, their output
     * (including fractional jitter) is completely determined by the
     * integer/fractional divisor configured in SMx_CLKDIV. This means that, if
     * multiple clock dividers with the same divisor are restarted
     * simultaneously, by writing multiple 1 bits to this field, the execution
     * clocks of those state machines will run in precise lockstep. Note that
     * setting/clearing SM_ENABLE does not stop the clock divider from running,
     * so once multiple state machines' clocks are synchronised, it is safe to
     * disable/reenable a state machine, whilst keeping the clock dividers in
     * sync. Note also that CLKDIV_RESTART can be written to whilst the state
     * machine is running, and this is useful to resynchronise clock dividers
     * after the divisors (SMx_CLKDIV) have been changed on-the-fly.
     */
    inline uint8_t get_CTRL_CLKDIV_RESTART() volatile
    {
        return (CTRL >> 8u) & 0xfu;
    }

    /**
     * Set CTRL's CLKDIV_RESTART field.
     *
     * Restart a state machine's clock divider from an initial phase of 0.
     * Clock dividers are free-running, so once started, their output
     * (including fractional jitter) is completely determined by the
     * integer/fractional divisor configured in SMx_CLKDIV. This means that, if
     * multiple clock dividers with the same divisor are restarted
     * simultaneously, by writing multiple 1 bits to this field, the execution
     * clocks of those state machines will run in precise lockstep. Note that
     * setting/clearing SM_ENABLE does not stop the clock divider from running,
     * so once multiple state machines' clocks are synchronised, it is safe to
     * disable/reenable a state machine, whilst keeping the clock dividers in
     * sync. Note also that CLKDIV_RESTART can be written to whilst the state
     * machine is running, and this is useful to resynchronise clock dividers
     * after the divisors (SMx_CLKDIV) have been changed on-the-fly.
     */
    inline void set_CTRL_CLKDIV_RESTART(uint8_t value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0xfu << 8u);
        curr |= (value & 0xfu) << 8u;

        CTRL = curr;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) PIO control register
     */
    inline void get_CTRL(uint8_t &SM_ENABLE, uint8_t &SM_RESTART,
                         uint8_t &CLKDIV_RESTART) volatile
    {
        uint32_t curr = CTRL;

        SM_ENABLE = curr & 0xfu;
        SM_RESTART = (curr >> 4u) & 0xfu;
        CLKDIV_RESTART = (curr >> 8u) & 0xfu;
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) PIO control register
     */
    inline void set_CTRL(uint8_t SM_ENABLE, uint8_t SM_RESTART,
                         uint8_t CLKDIV_RESTART) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0xfu);
        curr |= (SM_ENABLE & 0xfu);
        curr &= ~(0xfu << 4u);
        curr |= (SM_RESTART & 0xfu) << 4u;
        curr &= ~(0xfu << 8u);
        curr |= (CLKDIV_RESTART & 0xfu) << 8u;

        CTRL = curr;
    }

    /**
     * Get FSTAT's RXFULL field.
     *
     * State machine RX FIFO is full
     */
    inline uint8_t get_FSTAT_RXFULL() volatile
    {
        return FSTAT & 0xfu;
    }

    /**
     * Get FSTAT's RXEMPTY field.
     *
     * State machine RX FIFO is empty
     */
    inline uint8_t get_FSTAT_RXEMPTY() volatile
    {
        return (FSTAT >> 8u) & 0xfu;
    }

    /**
     * Get FSTAT's TXFULL field.
     *
     * State machine TX FIFO is full
     */
    inline uint8_t get_FSTAT_TXFULL() volatile
    {
        return (FSTAT >> 16u) & 0xfu;
    }

    /**
     * Get FSTAT's TXEMPTY field.
     *
     * State machine TX FIFO is empty
     */
    inline uint8_t get_FSTAT_TXEMPTY() volatile
    {
        return (FSTAT >> 24u) & 0xfu;
    }

    /**
     * Get all of FSTAT's bit fields.
     *
     * (read-only) FIFO status register
     */
    inline void get_FSTAT(uint8_t &RXFULL, uint8_t &RXEMPTY, uint8_t &TXFULL,
                          uint8_t &TXEMPTY) volatile
    {
        uint32_t curr = FSTAT;

        RXFULL = curr & 0xfu;
        RXEMPTY = (curr >> 8u) & 0xfu;
        TXFULL = (curr >> 16u) & 0xfu;
        TXEMPTY = (curr >> 24u) & 0xfu;
    }

    /**
     * Get FDEBUG's RXSTALL field.
     *
     * State machine has stalled on full RX FIFO during a blocking PUSH, or an
     * IN with autopush enabled. This flag is also set when a nonblocking PUSH
     * to a full FIFO took place, in which case the state machine has dropped
     * data. Write 1 to clear.
     */
    inline uint8_t get_FDEBUG_RXSTALL() volatile
    {
        return FDEBUG & 0xfu;
    }

    /**
     * Set FDEBUG's RXSTALL field.
     *
     * State machine has stalled on full RX FIFO during a blocking PUSH, or an
     * IN with autopush enabled. This flag is also set when a nonblocking PUSH
     * to a full FIFO took place, in which case the state machine has dropped
     * data. Write 1 to clear.
     */
    inline void set_FDEBUG_RXSTALL(uint8_t value) volatile
    {
        uint32_t curr = FDEBUG;

        curr &= ~(0xfu);
        curr |= (value & 0xfu);

        FDEBUG = curr;
    }

    /**
     * Get FDEBUG's RXUNDER field.
     *
     * RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write
     * 1 to clear. Note that read-on-empty does not perturb the state of the
     * FIFO in any way, but the data returned by reading from an empty FIFO is
     * undefined, so this flag generally only becomes set due to some kind of
     * software error.
     */
    inline uint8_t get_FDEBUG_RXUNDER() volatile
    {
        return (FDEBUG >> 8u) & 0xfu;
    }

    /**
     * Set FDEBUG's RXUNDER field.
     *
     * RX FIFO underflow (i.e. read-on-empty by the system) has occurred. Write
     * 1 to clear. Note that read-on-empty does not perturb the state of the
     * FIFO in any way, but the data returned by reading from an empty FIFO is
     * undefined, so this flag generally only becomes set due to some kind of
     * software error.
     */
    inline void set_FDEBUG_RXUNDER(uint8_t value) volatile
    {
        uint32_t curr = FDEBUG;

        curr &= ~(0xfu << 8u);
        curr |= (value & 0xfu) << 8u;

        FDEBUG = curr;
    }

    /**
     * Get FDEBUG's TXOVER field.
     *
     * TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write
     * 1 to clear. Note that write-on-full does not alter the state or contents
     * of the FIFO in any way, but the data that the system attempted to write
     * is dropped, so if this flag is set, your software has quite likely
     * dropped some data on the floor.
     */
    inline uint8_t get_FDEBUG_TXOVER() volatile
    {
        return (FDEBUG >> 16u) & 0xfu;
    }

    /**
     * Set FDEBUG's TXOVER field.
     *
     * TX FIFO overflow (i.e. write-on-full by the system) has occurred. Write
     * 1 to clear. Note that write-on-full does not alter the state or contents
     * of the FIFO in any way, but the data that the system attempted to write
     * is dropped, so if this flag is set, your software has quite likely
     * dropped some data on the floor.
     */
    inline void set_FDEBUG_TXOVER(uint8_t value) volatile
    {
        uint32_t curr = FDEBUG;

        curr &= ~(0xfu << 16u);
        curr |= (value & 0xfu) << 16u;

        FDEBUG = curr;
    }

    /**
     * Get FDEBUG's TXSTALL field.
     *
     * State machine has stalled on empty TX FIFO during a blocking PULL, or an
     * OUT with autopull enabled. Write 1 to clear.
     */
    inline uint8_t get_FDEBUG_TXSTALL() volatile
    {
        return (FDEBUG >> 24u) & 0xfu;
    }

    /**
     * Set FDEBUG's TXSTALL field.
     *
     * State machine has stalled on empty TX FIFO during a blocking PULL, or an
     * OUT with autopull enabled. Write 1 to clear.
     */
    inline void set_FDEBUG_TXSTALL(uint8_t value) volatile
    {
        uint32_t curr = FDEBUG;

        curr &= ~(0xfu << 24u);
        curr |= (value & 0xfu) << 24u;

        FDEBUG = curr;
    }

    /**
     * Get all of FDEBUG's bit fields.
     *
     * (read-write) FIFO debug register
     */
    inline void get_FDEBUG(uint8_t &RXSTALL, uint8_t &RXUNDER, uint8_t &TXOVER,
                           uint8_t &TXSTALL) volatile
    {
        uint32_t curr = FDEBUG;

        RXSTALL = curr & 0xfu;
        RXUNDER = (curr >> 8u) & 0xfu;
        TXOVER = (curr >> 16u) & 0xfu;
        TXSTALL = (curr >> 24u) & 0xfu;
    }

    /**
     * Set all of FDEBUG's bit fields.
     *
     * (read-write) FIFO debug register
     */
    inline void set_FDEBUG(uint8_t RXSTALL, uint8_t RXUNDER, uint8_t TXOVER,
                           uint8_t TXSTALL) volatile
    {
        uint32_t curr = FDEBUG;

        curr &= ~(0xfu);
        curr |= (RXSTALL & 0xfu);
        curr &= ~(0xfu << 8u);
        curr |= (RXUNDER & 0xfu) << 8u;
        curr &= ~(0xfu << 16u);
        curr |= (TXOVER & 0xfu) << 16u;
        curr &= ~(0xfu << 24u);
        curr |= (TXSTALL & 0xfu) << 24u;

        FDEBUG = curr;
    }

    /**
     * Get FLEVEL's TX0 field.
     */
    inline uint8_t get_FLEVEL_TX0() volatile
    {
        return FLEVEL & 0xfu;
    }

    /**
     * Get FLEVEL's RX0 field.
     */
    inline uint8_t get_FLEVEL_RX0() volatile
    {
        return (FLEVEL >> 4u) & 0xfu;
    }

    /**
     * Get FLEVEL's TX1 field.
     */
    inline uint8_t get_FLEVEL_TX1() volatile
    {
        return (FLEVEL >> 8u) & 0xfu;
    }

    /**
     * Get FLEVEL's RX1 field.
     */
    inline uint8_t get_FLEVEL_RX1() volatile
    {
        return (FLEVEL >> 12u) & 0xfu;
    }

    /**
     * Get FLEVEL's TX2 field.
     */
    inline uint8_t get_FLEVEL_TX2() volatile
    {
        return (FLEVEL >> 16u) & 0xfu;
    }

    /**
     * Get FLEVEL's RX2 field.
     */
    inline uint8_t get_FLEVEL_RX2() volatile
    {
        return (FLEVEL >> 20u) & 0xfu;
    }

    /**
     * Get FLEVEL's TX3 field.
     */
    inline uint8_t get_FLEVEL_TX3() volatile
    {
        return (FLEVEL >> 24u) & 0xfu;
    }

    /**
     * Get FLEVEL's RX3 field.
     */
    inline uint8_t get_FLEVEL_RX3() volatile
    {
        return (FLEVEL >> 28u) & 0xfu;
    }

    /**
     * Get all of FLEVEL's bit fields.
     *
     * (read-only) FIFO levels
     */
    inline void get_FLEVEL(uint8_t &TX0, uint8_t &RX0, uint8_t &TX1,
                           uint8_t &RX1, uint8_t &TX2, uint8_t &RX2,
                           uint8_t &TX3, uint8_t &RX3) volatile
    {
        uint32_t curr = FLEVEL;

        TX0 = curr & 0xfu;
        RX0 = (curr >> 4u) & 0xfu;
        TX1 = (curr >> 8u) & 0xfu;
        RX1 = (curr >> 12u) & 0xfu;
        TX2 = (curr >> 16u) & 0xfu;
        RX2 = (curr >> 20u) & 0xfu;
        TX3 = (curr >> 24u) & 0xfu;
        RX3 = (curr >> 28u) & 0xfu;
    }

    /**
     * Get IRQ's IRQ field.
     */
    inline uint8_t get_IRQ() volatile
    {
        return IRQ & 0xffu;
    }

    /**
     * Set IRQ's IRQ field.
     */
    inline void set_IRQ(uint8_t value) volatile
    {
        uint32_t curr = IRQ;

        curr &= ~(0xffu);
        curr |= (value & 0xffu);

        IRQ = curr;
    }

    /**
     * Set IRQ_FORCE's IRQ_FORCE field.
     */
    inline void set_IRQ_FORCE(uint8_t value) volatile
    {
        uint32_t curr = IRQ_FORCE;

        curr &= ~(0xffu);
        curr |= (value & 0xffu);

        IRQ_FORCE = curr;
    }

    /**
     * Get DBG_CFGINFO's FIFO_DEPTH field.
     *
     * The depth of the state machine TX/RX FIFOs, measured in words.
     *                 Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with
     * double this depth.
     */
    inline uint8_t get_DBG_CFGINFO_FIFO_DEPTH() volatile
    {
        return DBG_CFGINFO & 0b111111u;
    }

    /**
     * Get DBG_CFGINFO's SM_COUNT field.
     *
     * The number of state machines this PIO instance is equipped with.
     */
    inline uint8_t get_DBG_CFGINFO_SM_COUNT() volatile
    {
        return (DBG_CFGINFO >> 8u) & 0xfu;
    }

    /**
     * Get DBG_CFGINFO's IMEM_SIZE field.
     *
     * The size of the instruction memory, measured in units of one instruction
     */
    inline uint8_t get_DBG_CFGINFO_IMEM_SIZE() volatile
    {
        return (DBG_CFGINFO >> 16u) & 0b111111u;
    }

    /**
     * Get all of DBG_CFGINFO's bit fields.
     *
     * (read-only) The PIO hardware has some free parameters that may vary
     * between chip products. These should be provided in the chip datasheet,
     * but are also exposed here.
     */
    inline void get_DBG_CFGINFO(uint8_t &FIFO_DEPTH, uint8_t &SM_COUNT,
                                uint8_t &IMEM_SIZE) volatile
    {
        uint32_t curr = DBG_CFGINFO;

        FIFO_DEPTH = curr & 0b111111u;
        SM_COUNT = (curr >> 8u) & 0xfu;
        IMEM_SIZE = (curr >> 16u) & 0b111111u;
    }

    /**
     * Get INTR's SM0_RXNEMPTY bit.
     */
    inline bool get_INTR_SM0_RXNEMPTY() volatile
    {
        return INTR & 1u;
    }

    /**
     * Get INTR's SM1_RXNEMPTY bit.
     */
    inline bool get_INTR_SM1_RXNEMPTY() volatile
    {
        return INTR & (1u << 1u);
    }

    /**
     * Get INTR's SM2_RXNEMPTY bit.
     */
    inline bool get_INTR_SM2_RXNEMPTY() volatile
    {
        return INTR & (1u << 2u);
    }

    /**
     * Get INTR's SM3_RXNEMPTY bit.
     */
    inline bool get_INTR_SM3_RXNEMPTY() volatile
    {
        return INTR & (1u << 3u);
    }

    /**
     * Get INTR's SM0_TXNFULL bit.
     */
    inline bool get_INTR_SM0_TXNFULL() volatile
    {
        return INTR & (1u << 4u);
    }

    /**
     * Get INTR's SM1_TXNFULL bit.
     */
    inline bool get_INTR_SM1_TXNFULL() volatile
    {
        return INTR & (1u << 5u);
    }

    /**
     * Get INTR's SM2_TXNFULL bit.
     */
    inline bool get_INTR_SM2_TXNFULL() volatile
    {
        return INTR & (1u << 6u);
    }

    /**
     * Get INTR's SM3_TXNFULL bit.
     */
    inline bool get_INTR_SM3_TXNFULL() volatile
    {
        return INTR & (1u << 7u);
    }

    /**
     * Get INTR's SM0 bit.
     */
    inline bool get_INTR_SM0() volatile
    {
        return INTR & (1u << 8u);
    }

    /**
     * Get INTR's SM1 bit.
     */
    inline bool get_INTR_SM1() volatile
    {
        return INTR & (1u << 9u);
    }

    /**
     * Get INTR's SM2 bit.
     */
    inline bool get_INTR_SM2() volatile
    {
        return INTR & (1u << 10u);
    }

    /**
     * Get INTR's SM3 bit.
     */
    inline bool get_INTR_SM3() volatile
    {
        return INTR & (1u << 11u);
    }

    /**
     * Get all of INTR's bit fields.
     *
     * (read-only) Raw Interrupts
     */
    inline void get_INTR(bool &SM0_RXNEMPTY, bool &SM1_RXNEMPTY,
                         bool &SM2_RXNEMPTY, bool &SM3_RXNEMPTY,
                         bool &SM0_TXNFULL, bool &SM1_TXNFULL,
                         bool &SM2_TXNFULL, bool &SM3_TXNFULL, bool &SM0,
                         bool &SM1, bool &SM2, bool &SM3) volatile
    {
        uint32_t curr = INTR;

        SM0_RXNEMPTY = curr & 1u;
        SM1_RXNEMPTY = curr & (1u << 1u);
        SM2_RXNEMPTY = curr & (1u << 2u);
        SM3_RXNEMPTY = curr & (1u << 3u);
        SM0_TXNFULL = curr & (1u << 4u);
        SM1_TXNFULL = curr & (1u << 5u);
        SM2_TXNFULL = curr & (1u << 6u);
        SM3_TXNFULL = curr & (1u << 7u);
        SM0 = curr & (1u << 8u);
        SM1 = curr & (1u << 9u);
        SM2 = curr & (1u << 10u);
        SM3 = curr & (1u << 11u);
    }
};

static_assert(sizeof(pio) == pio::size);
static_assert(ifgen_struct<pio>);

static volatile pio *const PIO0 = reinterpret_cast<pio *>(0x50200000);

static volatile pio *const PIO1 = reinterpret_cast<pio *>(0x50300000);

}; // namespace RP2040

#endif
