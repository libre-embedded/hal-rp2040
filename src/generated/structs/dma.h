/**
 * \file
 * \brief Generated by ifgen (4.7.0).
 */

#pragma once
#ifndef RP2040_STRUCTS_DMA_H
#define RP2040_STRUCTS_DMA_H

#include "../enums/DMA_SNIFF_CTRL_CALC.h"
#include "../ifgen/common.h"
#include "dma_control.h"
#include "dma_debug.h"

namespace RP2040
{

/**
 * DMA with separate read and write masters
 */
struct dma
{
    /* Constant attributes. */
    static constexpr struct_id_t id = 6;      /*!< dma's identifier. */
    static constexpr std::size_t size = 3072; /*!< dma's size in bytes. */

    /* Fields. */
    std::array<dma_control, 16> CONTROL;
    uint32_t INTR;  /*!< (read-write) Interrupt Status (raw) */
    uint32_t INTE0; /*!< (read-write) Interrupt Enables for IRQ 0 */
    uint32_t INTF0; /*!< (read-write) Force Interrupts */
    uint32_t INTS0; /*!< (read-write) Interrupt Status for IRQ 0 */
    const uint32_t reserved_padding0 = {};
    uint32_t INTE1;  /*!< (read-write) Interrupt Enables for IRQ 1 */
    uint32_t INTF1;  /*!< (read-write) Force Interrupts for IRQ 1 */
    uint32_t INTS1;  /*!< (read-write) Interrupt Status (masked) for IRQ 1 */
    uint32_t TIMER0; /*!< (read-write) Pacing (X/Y) Fractional Timer
The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
This equation is evaluated every sys_clk cycles and therefore can only generate
TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */
    uint32_t TIMER1; /*!< (read-write) Pacing (X/Y) Fractional Timer
The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
This equation is evaluated every sys_clk cycles and therefore can only generate
TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */
    uint32_t TIMER2; /*!< (read-write) Pacing (X/Y) Fractional Timer
The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
This equation is evaluated every sys_clk cycles and therefore can only generate
TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */
    uint32_t TIMER3; /*!< (read-write) Pacing (X/Y) Fractional Timer
The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
This equation is evaluated every sys_clk cycles and therefore can only generate
TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */
    uint32_t MULTI_CHAN_TRIGGER; /*!< (read-write) Trigger one or more channels
                                    simultaneously */
    uint32_t SNIFF_CTRL;         /*!< (read-write) Sniffer Control */
    uint32_t SNIFF_DATA; /*!< (read-write) Data accumulator for sniff hardware
Write an initial seed value here before starting a DMA transfer on the channel
indicated by SNIFF_CTRL_DMACH. The hardware will update this register each time
it observes a read from the indicated channel. Once the channel completes, the
final result can be read from this register. */
    const uint32_t reserved_padding1 = {};
    const uint32_t FIFO_LEVELS =
        {};              /*!< (read-only) Debug RAF, WAF, TDF levels */
    uint32_t CHAN_ABORT; /*!< (read-write) Abort an in-progress transfer
                            sequence on one or more channels */
    const uint32_t N_CHANNELS =
        {}; /*!< (read-only) The number of channels this DMA instance is
               equipped with. This DMA supports up to 16 hardware channels, but
               can be configured with as few as one, to minimise silicon area.
             */
    std::array<const uint32_t, 237> reserved_padding2 = {};
    std::array<dma_debug, 16> DEBUG;

    /* Methods. */

    /**
     * Get INTR's INTR field.
     *
     * Raw interrupt status for DMA Channels 0..15. Bit n corresponds to
     * channel n. Ignores any masking or forcing. Channel interrupts can be
     * cleared by writing a bit mask to INTR, INTS0 or INTS1. Channel
     * interrupts can be routed to either of two system-level IRQs based on
     * INTE0 and INTE1. This can be used vector different channel interrupts to
     * different ISRs: this might be done to allow NVIC IRQ preemption for more
     * time-critical channels, or to spread IRQ load across different cores. It
     * is also valid to ignore this behaviour and just use INTE0/INTS0/IRQ 0.
     */
    inline uint16_t get_INTR() volatile
    {
        return INTR & 0xffffu;
    }

    /**
     * Set INTR's INTR field.
     *
     * Raw interrupt status for DMA Channels 0..15. Bit n corresponds to
     * channel n. Ignores any masking or forcing. Channel interrupts can be
     * cleared by writing a bit mask to INTR, INTS0 or INTS1. Channel
     * interrupts can be routed to either of two system-level IRQs based on
     * INTE0 and INTE1. This can be used vector different channel interrupts to
     * different ISRs: this might be done to allow NVIC IRQ preemption for more
     * time-critical channels, or to spread IRQ load across different cores. It
     * is also valid to ignore this behaviour and just use INTE0/INTS0/IRQ 0.
     */
    inline void set_INTR(uint16_t value) volatile
    {
        uint32_t curr = INTR;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        INTR = curr;
    }

    /**
     * Get INTE0's INTE0 field.
     *
     * Set bit n to pass interrupts from channel n to DMA IRQ 0.
     */
    inline uint16_t get_INTE0() volatile
    {
        return INTE0 & 0xffffu;
    }

    /**
     * Set INTE0's INTE0 field.
     *
     * Set bit n to pass interrupts from channel n to DMA IRQ 0.
     */
    inline void set_INTE0(uint16_t value) volatile
    {
        uint32_t curr = INTE0;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        INTE0 = curr;
    }

    /**
     * Get INTF0's INTF0 field.
     *
     * Write 1s to force the corresponding bits in INTE0. The interrupt remains
     * asserted until INTF0 is cleared.
     */
    inline uint16_t get_INTF0() volatile
    {
        return INTF0 & 0xffffu;
    }

    /**
     * Set INTF0's INTF0 field.
     *
     * Write 1s to force the corresponding bits in INTE0. The interrupt remains
     * asserted until INTF0 is cleared.
     */
    inline void set_INTF0(uint16_t value) volatile
    {
        uint32_t curr = INTF0;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        INTF0 = curr;
    }

    /**
     * Get INTS0's INTS0 field.
     *
     * Indicates active channel interrupt requests which are currently causing
     * IRQ 0 to be asserted. Channel interrupts can be cleared by writing a bit
     * mask here.
     */
    inline uint16_t get_INTS0() volatile
    {
        return INTS0 & 0xffffu;
    }

    /**
     * Set INTS0's INTS0 field.
     *
     * Indicates active channel interrupt requests which are currently causing
     * IRQ 0 to be asserted. Channel interrupts can be cleared by writing a bit
     * mask here.
     */
    inline void set_INTS0(uint16_t value) volatile
    {
        uint32_t curr = INTS0;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        INTS0 = curr;
    }

    /**
     * Get INTE1's INTE1 field.
     *
     * Set bit n to pass interrupts from channel n to DMA IRQ 1.
     */
    inline uint16_t get_INTE1() volatile
    {
        return INTE1 & 0xffffu;
    }

    /**
     * Set INTE1's INTE1 field.
     *
     * Set bit n to pass interrupts from channel n to DMA IRQ 1.
     */
    inline void set_INTE1(uint16_t value) volatile
    {
        uint32_t curr = INTE1;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        INTE1 = curr;
    }

    /**
     * Get INTF1's INTF1 field.
     *
     * Write 1s to force the corresponding bits in INTE0. The interrupt remains
     * asserted until INTF0 is cleared.
     */
    inline uint16_t get_INTF1() volatile
    {
        return INTF1 & 0xffffu;
    }

    /**
     * Set INTF1's INTF1 field.
     *
     * Write 1s to force the corresponding bits in INTE0. The interrupt remains
     * asserted until INTF0 is cleared.
     */
    inline void set_INTF1(uint16_t value) volatile
    {
        uint32_t curr = INTF1;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        INTF1 = curr;
    }

    /**
     * Get INTS1's INTS1 field.
     *
     * Indicates active channel interrupt requests which are currently causing
     * IRQ 1 to be asserted. Channel interrupts can be cleared by writing a bit
     * mask here.
     */
    inline uint16_t get_INTS1() volatile
    {
        return INTS1 & 0xffffu;
    }

    /**
     * Set INTS1's INTS1 field.
     *
     * Indicates active channel interrupt requests which are currently causing
     * IRQ 1 to be asserted. Channel interrupts can be cleared by writing a bit
     * mask here.
     */
    inline void set_INTS1(uint16_t value) volatile
    {
        uint32_t curr = INTS1;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        INTS1 = curr;
    }

    /**
     * Get TIMER0's Y field.
     *
     * Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
     * timer.
     */
    inline uint16_t get_TIMER0_Y() volatile
    {
        return TIMER0 & 0xffffu;
    }

    /**
     * Set TIMER0's Y field.
     *
     * Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
     * timer.
     */
    inline void set_TIMER0_Y(uint16_t value) volatile
    {
        uint32_t curr = TIMER0;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        TIMER0 = curr;
    }

    /**
     * Get TIMER0's X field.
     *
     * Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
     * timer.
     */
    inline uint16_t get_TIMER0_X() volatile
    {
        return (TIMER0 >> 16u) & 0xffffu;
    }

    /**
     * Set TIMER0's X field.
     *
     * Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
     * timer.
     */
    inline void set_TIMER0_X(uint16_t value) volatile
    {
        uint32_t curr = TIMER0;

        curr &= ~(0xffffu << 16u);
        curr |= (value & 0xffffu) << 16u;

        TIMER0 = curr;
    }

    /**
     * Get all of TIMER0's bit fields.
     *
     * (read-write) Pacing (X/Y) Fractional Timer
     *             The pacing timer produces TREQ assertions at a rate set by
     * ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and
     * therefore can only generate TREQs at a rate of 1 per sys_clk (i.e.
     * permanent TREQ) or less.
     */
    inline void get_TIMER0(uint16_t &Y, uint16_t &X) volatile
    {
        uint32_t curr = TIMER0;

        Y = curr & 0xffffu;
        X = (curr >> 16u) & 0xffffu;
    }

    /**
     * Set all of TIMER0's bit fields.
     *
     * (read-write) Pacing (X/Y) Fractional Timer
     *             The pacing timer produces TREQ assertions at a rate set by
     * ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and
     * therefore can only generate TREQs at a rate of 1 per sys_clk (i.e.
     * permanent TREQ) or less.
     */
    inline void set_TIMER0(uint16_t Y, uint16_t X) volatile
    {
        uint32_t curr = TIMER0;

        curr &= ~(0xffffu);
        curr |= (Y & 0xffffu);
        curr &= ~(0xffffu << 16u);
        curr |= (X & 0xffffu) << 16u;

        TIMER0 = curr;
    }

    /**
     * Get TIMER1's Y field.
     *
     * Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
     * timer.
     */
    inline uint16_t get_TIMER1_Y() volatile
    {
        return TIMER1 & 0xffffu;
    }

    /**
     * Set TIMER1's Y field.
     *
     * Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
     * timer.
     */
    inline void set_TIMER1_Y(uint16_t value) volatile
    {
        uint32_t curr = TIMER1;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        TIMER1 = curr;
    }

    /**
     * Get TIMER1's X field.
     *
     * Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
     * timer.
     */
    inline uint16_t get_TIMER1_X() volatile
    {
        return (TIMER1 >> 16u) & 0xffffu;
    }

    /**
     * Set TIMER1's X field.
     *
     * Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
     * timer.
     */
    inline void set_TIMER1_X(uint16_t value) volatile
    {
        uint32_t curr = TIMER1;

        curr &= ~(0xffffu << 16u);
        curr |= (value & 0xffffu) << 16u;

        TIMER1 = curr;
    }

    /**
     * Get all of TIMER1's bit fields.
     *
     * (read-write) Pacing (X/Y) Fractional Timer
     *             The pacing timer produces TREQ assertions at a rate set by
     * ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and
     * therefore can only generate TREQs at a rate of 1 per sys_clk (i.e.
     * permanent TREQ) or less.
     */
    inline void get_TIMER1(uint16_t &Y, uint16_t &X) volatile
    {
        uint32_t curr = TIMER1;

        Y = curr & 0xffffu;
        X = (curr >> 16u) & 0xffffu;
    }

    /**
     * Set all of TIMER1's bit fields.
     *
     * (read-write) Pacing (X/Y) Fractional Timer
     *             The pacing timer produces TREQ assertions at a rate set by
     * ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and
     * therefore can only generate TREQs at a rate of 1 per sys_clk (i.e.
     * permanent TREQ) or less.
     */
    inline void set_TIMER1(uint16_t Y, uint16_t X) volatile
    {
        uint32_t curr = TIMER1;

        curr &= ~(0xffffu);
        curr |= (Y & 0xffffu);
        curr &= ~(0xffffu << 16u);
        curr |= (X & 0xffffu) << 16u;

        TIMER1 = curr;
    }

    /**
     * Get TIMER2's Y field.
     *
     * Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
     * timer.
     */
    inline uint16_t get_TIMER2_Y() volatile
    {
        return TIMER2 & 0xffffu;
    }

    /**
     * Set TIMER2's Y field.
     *
     * Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
     * timer.
     */
    inline void set_TIMER2_Y(uint16_t value) volatile
    {
        uint32_t curr = TIMER2;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        TIMER2 = curr;
    }

    /**
     * Get TIMER2's X field.
     *
     * Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
     * timer.
     */
    inline uint16_t get_TIMER2_X() volatile
    {
        return (TIMER2 >> 16u) & 0xffffu;
    }

    /**
     * Set TIMER2's X field.
     *
     * Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
     * timer.
     */
    inline void set_TIMER2_X(uint16_t value) volatile
    {
        uint32_t curr = TIMER2;

        curr &= ~(0xffffu << 16u);
        curr |= (value & 0xffffu) << 16u;

        TIMER2 = curr;
    }

    /**
     * Get all of TIMER2's bit fields.
     *
     * (read-write) Pacing (X/Y) Fractional Timer
     *             The pacing timer produces TREQ assertions at a rate set by
     * ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and
     * therefore can only generate TREQs at a rate of 1 per sys_clk (i.e.
     * permanent TREQ) or less.
     */
    inline void get_TIMER2(uint16_t &Y, uint16_t &X) volatile
    {
        uint32_t curr = TIMER2;

        Y = curr & 0xffffu;
        X = (curr >> 16u) & 0xffffu;
    }

    /**
     * Set all of TIMER2's bit fields.
     *
     * (read-write) Pacing (X/Y) Fractional Timer
     *             The pacing timer produces TREQ assertions at a rate set by
     * ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and
     * therefore can only generate TREQs at a rate of 1 per sys_clk (i.e.
     * permanent TREQ) or less.
     */
    inline void set_TIMER2(uint16_t Y, uint16_t X) volatile
    {
        uint32_t curr = TIMER2;

        curr &= ~(0xffffu);
        curr |= (Y & 0xffffu);
        curr &= ~(0xffffu << 16u);
        curr |= (X & 0xffffu) << 16u;

        TIMER2 = curr;
    }

    /**
     * Get TIMER3's Y field.
     *
     * Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
     * timer.
     */
    inline uint16_t get_TIMER3_Y() volatile
    {
        return TIMER3 & 0xffffu;
    }

    /**
     * Set TIMER3's Y field.
     *
     * Pacing Timer Divisor. Specifies the Y value for the (X/Y) fractional
     * timer.
     */
    inline void set_TIMER3_Y(uint16_t value) volatile
    {
        uint32_t curr = TIMER3;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        TIMER3 = curr;
    }

    /**
     * Get TIMER3's X field.
     *
     * Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
     * timer.
     */
    inline uint16_t get_TIMER3_X() volatile
    {
        return (TIMER3 >> 16u) & 0xffffu;
    }

    /**
     * Set TIMER3's X field.
     *
     * Pacing Timer Dividend. Specifies the X value for the (X/Y) fractional
     * timer.
     */
    inline void set_TIMER3_X(uint16_t value) volatile
    {
        uint32_t curr = TIMER3;

        curr &= ~(0xffffu << 16u);
        curr |= (value & 0xffffu) << 16u;

        TIMER3 = curr;
    }

    /**
     * Get all of TIMER3's bit fields.
     *
     * (read-write) Pacing (X/Y) Fractional Timer
     *             The pacing timer produces TREQ assertions at a rate set by
     * ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and
     * therefore can only generate TREQs at a rate of 1 per sys_clk (i.e.
     * permanent TREQ) or less.
     */
    inline void get_TIMER3(uint16_t &Y, uint16_t &X) volatile
    {
        uint32_t curr = TIMER3;

        Y = curr & 0xffffu;
        X = (curr >> 16u) & 0xffffu;
    }

    /**
     * Set all of TIMER3's bit fields.
     *
     * (read-write) Pacing (X/Y) Fractional Timer
     *             The pacing timer produces TREQ assertions at a rate set by
     * ((X/Y) * sys_clk). This equation is evaluated every sys_clk cycles and
     * therefore can only generate TREQs at a rate of 1 per sys_clk (i.e.
     * permanent TREQ) or less.
     */
    inline void set_TIMER3(uint16_t Y, uint16_t X) volatile
    {
        uint32_t curr = TIMER3;

        curr &= ~(0xffffu);
        curr |= (Y & 0xffffu);
        curr &= ~(0xffffu << 16u);
        curr |= (X & 0xffffu) << 16u;

        TIMER3 = curr;
    }

    /**
     * Get MULTI_CHAN_TRIGGER's MULTI_CHAN_TRIGGER field.
     *
     * Each bit in this register corresponds to a DMA channel. Writing a 1 to
     * the relevant bit is the same as writing to that channel's trigger
     * register; the channel will start if it is currently enabled and not
     * already busy.
     */
    inline uint16_t get_MULTI_CHAN_TRIGGER() volatile
    {
        return MULTI_CHAN_TRIGGER & 0xffffu;
    }

    /**
     * Set MULTI_CHAN_TRIGGER's MULTI_CHAN_TRIGGER field.
     *
     * Each bit in this register corresponds to a DMA channel. Writing a 1 to
     * the relevant bit is the same as writing to that channel's trigger
     * register; the channel will start if it is currently enabled and not
     * already busy.
     */
    inline void set_MULTI_CHAN_TRIGGER(uint16_t value) volatile
    {
        uint32_t curr = MULTI_CHAN_TRIGGER;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        MULTI_CHAN_TRIGGER = curr;
    }

    /**
     * Get SNIFF_CTRL's EN bit.
     *
     * Enable sniffer
     */
    inline bool get_SNIFF_CTRL_EN() volatile
    {
        return SNIFF_CTRL & 1u;
    }

    /**
     * Set SNIFF_CTRL's EN bit.
     *
     * Enable sniffer
     */
    inline void set_SNIFF_CTRL_EN() volatile
    {
        SNIFF_CTRL |= 1u;
    }

    /**
     * Clear SNIFF_CTRL's EN bit.
     *
     * Enable sniffer
     */
    inline void clear_SNIFF_CTRL_EN() volatile
    {
        SNIFF_CTRL &= ~(1u);
    }

    /**
     * Toggle SNIFF_CTRL's EN bit.
     *
     * Enable sniffer
     */
    inline void toggle_SNIFF_CTRL_EN() volatile
    {
        SNIFF_CTRL ^= 1u;
    }

    /**
     * Get SNIFF_CTRL's DMACH field.
     *
     * DMA channel for Sniffer to observe
     */
    inline uint8_t get_SNIFF_CTRL_DMACH() volatile
    {
        return (SNIFF_CTRL >> 1u) & 0xfu;
    }

    /**
     * Set SNIFF_CTRL's DMACH field.
     *
     * DMA channel for Sniffer to observe
     */
    inline void set_SNIFF_CTRL_DMACH(uint8_t value) volatile
    {
        uint32_t curr = SNIFF_CTRL;

        curr &= ~(0xfu << 1u);
        curr |= (value & 0xfu) << 1u;

        SNIFF_CTRL = curr;
    }

    /**
     * Get SNIFF_CTRL's CALC field.
     */
    inline DMA_SNIFF_CTRL_CALC get_SNIFF_CTRL_CALC() volatile
    {
        return DMA_SNIFF_CTRL_CALC((SNIFF_CTRL >> 5u) & 0xfu);
    }

    /**
     * Set SNIFF_CTRL's CALC field.
     */
    inline void set_SNIFF_CTRL_CALC(DMA_SNIFF_CTRL_CALC value) volatile
    {
        uint32_t curr = SNIFF_CTRL;

        curr &= ~(0xfu << 5u);
        curr |= (std::to_underlying(value) & 0xfu) << 5u;

        SNIFF_CTRL = curr;
    }

    /**
     * Get SNIFF_CTRL's BSWAP bit.
     *
     * Locally perform a byte reverse on the sniffed data, before feeding into
     * checksum. Note that the sniff hardware is downstream of the DMA channel
     * byteswap performed in the read master: if channel CTRL_BSWAP and
     * SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the
     * sniffer's point of view.
     */
    inline bool get_SNIFF_CTRL_BSWAP() volatile
    {
        return SNIFF_CTRL & (1u << 9u);
    }

    /**
     * Set SNIFF_CTRL's BSWAP bit.
     *
     * Locally perform a byte reverse on the sniffed data, before feeding into
     * checksum. Note that the sniff hardware is downstream of the DMA channel
     * byteswap performed in the read master: if channel CTRL_BSWAP and
     * SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the
     * sniffer's point of view.
     */
    inline void set_SNIFF_CTRL_BSWAP() volatile
    {
        SNIFF_CTRL |= 1u << 9u;
    }

    /**
     * Clear SNIFF_CTRL's BSWAP bit.
     *
     * Locally perform a byte reverse on the sniffed data, before feeding into
     * checksum. Note that the sniff hardware is downstream of the DMA channel
     * byteswap performed in the read master: if channel CTRL_BSWAP and
     * SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the
     * sniffer's point of view.
     */
    inline void clear_SNIFF_CTRL_BSWAP() volatile
    {
        SNIFF_CTRL &= ~(1u << 9u);
    }

    /**
     * Toggle SNIFF_CTRL's BSWAP bit.
     *
     * Locally perform a byte reverse on the sniffed data, before feeding into
     * checksum. Note that the sniff hardware is downstream of the DMA channel
     * byteswap performed in the read master: if channel CTRL_BSWAP and
     * SNIFF_CTRL_BSWAP are both enabled, their effects cancel from the
     * sniffer's point of view.
     */
    inline void toggle_SNIFF_CTRL_BSWAP() volatile
    {
        SNIFF_CTRL ^= 1u << 9u;
    }

    /**
     * Get SNIFF_CTRL's OUT_REV bit.
     *
     * If set, the result appears bit-reversed when read. This does not affect
     * the way the checksum is calculated; the result is transformed on-the-fly
     * between the result register and the bus.
     */
    inline bool get_SNIFF_CTRL_OUT_REV() volatile
    {
        return SNIFF_CTRL & (1u << 10u);
    }

    /**
     * Set SNIFF_CTRL's OUT_REV bit.
     *
     * If set, the result appears bit-reversed when read. This does not affect
     * the way the checksum is calculated; the result is transformed on-the-fly
     * between the result register and the bus.
     */
    inline void set_SNIFF_CTRL_OUT_REV() volatile
    {
        SNIFF_CTRL |= 1u << 10u;
    }

    /**
     * Clear SNIFF_CTRL's OUT_REV bit.
     *
     * If set, the result appears bit-reversed when read. This does not affect
     * the way the checksum is calculated; the result is transformed on-the-fly
     * between the result register and the bus.
     */
    inline void clear_SNIFF_CTRL_OUT_REV() volatile
    {
        SNIFF_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle SNIFF_CTRL's OUT_REV bit.
     *
     * If set, the result appears bit-reversed when read. This does not affect
     * the way the checksum is calculated; the result is transformed on-the-fly
     * between the result register and the bus.
     */
    inline void toggle_SNIFF_CTRL_OUT_REV() volatile
    {
        SNIFF_CTRL ^= 1u << 10u;
    }

    /**
     * Get SNIFF_CTRL's OUT_INV bit.
     *
     * If set, the result appears inverted (bitwise complement) when read. This
     * does not affect the way the checksum is calculated; the result is
     * transformed on-the-fly between the result register and the bus.
     */
    inline bool get_SNIFF_CTRL_OUT_INV() volatile
    {
        return SNIFF_CTRL & (1u << 11u);
    }

    /**
     * Set SNIFF_CTRL's OUT_INV bit.
     *
     * If set, the result appears inverted (bitwise complement) when read. This
     * does not affect the way the checksum is calculated; the result is
     * transformed on-the-fly between the result register and the bus.
     */
    inline void set_SNIFF_CTRL_OUT_INV() volatile
    {
        SNIFF_CTRL |= 1u << 11u;
    }

    /**
     * Clear SNIFF_CTRL's OUT_INV bit.
     *
     * If set, the result appears inverted (bitwise complement) when read. This
     * does not affect the way the checksum is calculated; the result is
     * transformed on-the-fly between the result register and the bus.
     */
    inline void clear_SNIFF_CTRL_OUT_INV() volatile
    {
        SNIFF_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle SNIFF_CTRL's OUT_INV bit.
     *
     * If set, the result appears inverted (bitwise complement) when read. This
     * does not affect the way the checksum is calculated; the result is
     * transformed on-the-fly between the result register and the bus.
     */
    inline void toggle_SNIFF_CTRL_OUT_INV() volatile
    {
        SNIFF_CTRL ^= 1u << 11u;
    }

    /**
     * Get all of SNIFF_CTRL's bit fields.
     *
     * (read-write) Sniffer Control
     */
    inline void get_SNIFF_CTRL(bool &EN, uint8_t &DMACH,
                               DMA_SNIFF_CTRL_CALC &CALC, bool &BSWAP,
                               bool &OUT_REV, bool &OUT_INV) volatile
    {
        uint32_t curr = SNIFF_CTRL;

        EN = curr & 1u;
        DMACH = (curr >> 1u) & 0xfu;
        CALC = DMA_SNIFF_CTRL_CALC((curr >> 5u) & 0xfu);
        BSWAP = curr & (1u << 9u);
        OUT_REV = curr & (1u << 10u);
        OUT_INV = curr & (1u << 11u);
    }

    /**
     * Set all of SNIFF_CTRL's bit fields.
     *
     * (read-write) Sniffer Control
     */
    inline void set_SNIFF_CTRL(bool EN, uint8_t DMACH,
                               DMA_SNIFF_CTRL_CALC CALC, bool BSWAP,
                               bool OUT_REV, bool OUT_INV) volatile
    {
        uint32_t curr = SNIFF_CTRL;

        curr &= ~(0b1u);
        curr |= (EN & 0b1u);
        curr &= ~(0xfu << 1u);
        curr |= (DMACH & 0xfu) << 1u;
        curr &= ~(0xfu << 5u);
        curr |= (std::to_underlying(CALC) & 0xfu) << 5u;
        curr &= ~(0b1u << 9u);
        curr |= (BSWAP & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (OUT_REV & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (OUT_INV & 0b1u) << 11u;

        SNIFF_CTRL = curr;
    }

    /**
     * Get FIFO_LEVELS's TDF_LVL field.
     *
     * Current Transfer-Data-FIFO fill level
     */
    inline uint8_t get_FIFO_LEVELS_TDF_LVL() volatile
    {
        return FIFO_LEVELS & 0xffu;
    }

    /**
     * Get FIFO_LEVELS's WAF_LVL field.
     *
     * Current Write-Address-FIFO fill level
     */
    inline uint8_t get_FIFO_LEVELS_WAF_LVL() volatile
    {
        return (FIFO_LEVELS >> 8u) & 0xffu;
    }

    /**
     * Get FIFO_LEVELS's RAF_LVL field.
     *
     * Current Read-Address-FIFO fill level
     */
    inline uint8_t get_FIFO_LEVELS_RAF_LVL() volatile
    {
        return (FIFO_LEVELS >> 16u) & 0xffu;
    }

    /**
     * Get all of FIFO_LEVELS's bit fields.
     *
     * (read-only) Debug RAF, WAF, TDF levels
     */
    inline void get_FIFO_LEVELS(uint8_t &TDF_LVL, uint8_t &WAF_LVL,
                                uint8_t &RAF_LVL) volatile
    {
        uint32_t curr = FIFO_LEVELS;

        TDF_LVL = curr & 0xffu;
        WAF_LVL = (curr >> 8u) & 0xffu;
        RAF_LVL = (curr >> 16u) & 0xffu;
    }

    /**
     * Get CHAN_ABORT's CHAN_ABORT field.
     *
     * Each bit corresponds to a channel. Writing a 1 aborts whatever transfer
     * sequence is in progress on that channel. The bit will remain high until
     * any in-flight transfers have been flushed through the address and data
     * FIFOs. After writing, this register must be polled until it returns
     * all-zero. Until this point, it is unsafe to restart the channel.
     */
    inline uint16_t get_CHAN_ABORT() volatile
    {
        return CHAN_ABORT & 0xffffu;
    }

    /**
     * Set CHAN_ABORT's CHAN_ABORT field.
     *
     * Each bit corresponds to a channel. Writing a 1 aborts whatever transfer
     * sequence is in progress on that channel. The bit will remain high until
     * any in-flight transfers have been flushed through the address and data
     * FIFOs. After writing, this register must be polled until it returns
     * all-zero. Until this point, it is unsafe to restart the channel.
     */
    inline void set_CHAN_ABORT(uint16_t value) volatile
    {
        uint32_t curr = CHAN_ABORT;

        curr &= ~(0xffffu);
        curr |= (value & 0xffffu);

        CHAN_ABORT = curr;
    }

    /**
     * Get N_CHANNELS's N_CHANNELS field.
     */
    inline uint8_t get_N_CHANNELS() volatile
    {
        return N_CHANNELS & 0b11111u;
    }
};

static_assert(sizeof(dma) == dma::size);
static_assert(ifgen_struct<dma>);

static volatile dma *const DMA = reinterpret_cast<dma *>(0x50000000);

}; // namespace RP2040

#endif
